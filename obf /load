-- DN MENU
-- Versão: 5.2
-- ==========================================
local Services = {
    Players = game:GetService("Players"),
    RunService = game:GetService("RunService"),
    UserInputService = game:GetService("UserInputService"),
    TweenService = game:GetService("TweenService"),
    Workspace = game:GetService("Workspace"),
    Lighting = game:GetService("Lighting"),
    HttpService = game:GetService("HttpService"),
    ReplicatedStorage = game:GetService("ReplicatedStorage"),
    CoreGui = game:GetService("CoreGui"),
    CollectionService = game:GetService("CollectionService"),
}
local LocalPlayer = Services.Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

local Config = {
    Version = "5.0",
    Author = "DN Softwares",
    Title = "DN Menu",
    AllowedUsersURL = "https://dnsoftwares.vercel.app/usermenu?token=LoadV5",
    DiscordInvite = "https://discord.gg/vBPFAg8kHW",
    Colors = {
        Main = Color3.fromRGB(138, 43, 226),
        Secondary = Color3.fromRGB(30, 30, 30),
        Success = Color3.fromRGB(70, 231, 137),
        Warning = Color3.fromRGB(255, 214, 49),
        Error = Color3.fromRGB(249, 44, 21),
        Info = Color3.fromRGB(40, 169, 255)
    },
    Defaults = {
        Speed = 16,
        JumpPower = 50,
        VehicleRange = 100,
        CameraFOV = 70,
    },
    Performance = {
        VehicleCacheInterval = 20,
        ESPUpdateRate = 0.5,
        MaxESPDistance = 300,
        MaxVehicleDistance = 200,
        AutoDisableOnLowFPS = true,
        LowFPSThreshold = 25,
    },
    User = {
        Enabled = true,
        Anonymous = false,
        Callback = function()
            return {
                Discord = "DN Menu User",
                Description = "Acesso restrito a usuários específicos"
            }
        end,
    },

    externos = {
    
        Telekinesis = "https://raw.githubusercontent.com/randomstring0/Qwerty/refs/heads/main/qwerty1.lua",
        IYRemodel = "https://raw.githubusercontent.com/froumes/badinfiniteyield/refs/heads/master/source",
        PedroxzMenu = "https://raw.githubusercontent.com/Pedroxz63/PedroxzMenuAtualizado/refs/heads/main/pedroxzmenuv.2.0.2.md",
    }
}

local ExunysDeveloperAimbot = loadstring(game:HttpGet("https://raw.githubusercontent.com/Exunys/Aimbot-V3/refs/heads/main/src/Aimbot.lua"))()
local ExunysDeveloperESP = loadstring(game:HttpGet("https://raw.githubusercontent.com/Exunys/Exunys-ESP/refs/heads/main/src/ESP.lua"))()
    
-- Função de gradiente (copie para o início do seu código, antes da InitializeMainUI)
local function gradient(text, startColor, endColor)
    local result = ""
    local length = #text
    for i = 1, length do
        local t = (i - 1) / math.max(length - 1, 1)
        local r = math.floor((startColor.R + (endColor.R - startColor.R) * t) * 255)
        local g = math.floor((startColor.G + (endColor.G - startColor.G) * t) * 255)
        local b = math.floor((startColor.B + (endColor.B - startColor.B) * t) * 255)
        local char = text:sub(i, i)
        result = result .. "<font color=\"rgb(" .. r ..", " .. g .. ", " .. b .. ")\">" .. char .. "</font>"
    end
    return result
end

local State = {
    Features = {
        Speed = {active = false, value = Config.Defaults.Speed, toggle = nil, connection = nil},
        JumpPower = {active = false, value = Config.Defaults.JumpPower, toggle = nil, connection = nil},
        Godmode = {active = false, toggle = nil},
        CameraFOV = Config.Defaults.CameraFOV,
ESP = {
        active = false,
        loaded = false,
        color = Color3.fromRGB(255, 255, 255),
        boxColor = Color3.fromRGB(138, 43, 226),
        invisibleBoxColor = Color3.fromRGB(255, 0, 0),
        selfESP = false,          -- NOVO
        visibleCheck = true,      -- NOVO
        toggle = nil,
        selfESPToggle = nil,      -- para referência na UI
        visibleCheckToggle = nil
    },
        CarESP = {
    active = false,
    toggle = nil
},
        ESPSkeleton = {
            active = false,
            connections = {},
            lines = {},
            color = Color3.fromRGB(138, 43, 226),
            toggle = nil
        },
        ESPRGB = {
            active = false,
            toggle = nil
        },
        ESPAdmin = {
            active = false,
            adminColor = Color3.fromRGB(255, 0, 0),
            toggle = nil,
            connections = {},
            billboards = {},
            maxDistance = 500
        },
        Chams = {
            active = false,
            folder = nil,
            fillColor = Color3.fromRGB(138, 43, 226),
            outlineColor = Color3.fromRGB(75, 0, 130),
            toggle = nil
        },
        Fullbright = {active = false, original = {}, toggle = nil},
        GunPull = {active = false, connection = nil, toggle = nil, lastPull = 0, pullRate = 0.5},
        Exorcismo = {
            active = false,
            connection = nil,
            originalAnimateScript = nil,
            toggle = nil,
            backupAnimations = {}
        },
        BangPlayer = {
            active = false,
            connection = nil,
            target = nil,
            toggle = nil,
            bangSpeed = 0.15,
            bangDistance = 1.5,
            isMovingBack = false
        },
        VehicleLauncher = {
            active = false,
            connection = nil,
            selectedVehicle = nil,
            onHead = false,
            toggle = nil,
            holding = false,
            alignPosition = nil,
            alignOrientation = nil,
            attachment0 = nil,
            attachment1 = nil,
            animTrack = nil
        },
Aimbot = {
        Loaded = false,
        Enabled = false,
        FOVRadius = 90,
        FOVColor = Color3.fromRGB(138, 43, 226),
        WallCheck = false,
        ShowFOV = true,          -- já existia, agora controlada por toggle separado
        TargetPart = "Head",
        FriendCheck = false,
        Smoothness = 0.3,
        toggle = nil,
        showFOVToggle = nil      -- novo toggle na UI
    },
MagicBullet = {
    active = false,
    toggle = nil,
    requiresChams = true
},
HeadHitboxExpander = {
    active = false,
    size = 10,
    transparency = 1,
    toggle = nil,
    originalSizes = {},
    playerAddedConnection = nil  -- ADICIONAR ESTA LINHA
},
        Noclip = {
            active = false,
            connection = nil,
            toggle = nil
        },
        SoloSession = {
            active = false,
            oldPos = nil,
            oldCamType = nil,
            oldCamCFrame = nil,
            toggle = nil
        },
        AutoUnlock = {
            active = false,
            connection = nil,
            toggle = nil,
            lastUnlock = 0,
            unlockRate = 0.5
        },
        VehicleDelete = {
            active = false,
            connection = nil,
            toggle = nil
        },
        VehicleFly = {
            active = false,
            speed = 50,
            keys = {},
            connections = {},
            bodyForce = nil,
            toggle = nil
        },
        VehicleNoclip = {
            active = false,
            connection = nil,
            toggle = nil
        },
        LowLagMode = {
            active = false,
            toggle = nil
        }
    },
    Players = {
        list = {},
        selected = nil
    },
    Vehicles = {
        unlockRange = Config.Defaults.VehicleRange,
        cache = {},
        lastCacheUpdate = 0,
        cacheUpdateInterval = Config.Performance.VehicleCacheInterval
    },
    PortaMalas = {
        pulling = false,
        vehicleData = {},
        statusLabel = nil,
        monitorConnection = nil,
        isRefreshing = false,
        lastRefreshTime = 0
    },
    UI = {
        window = nil,
        screenGui = nil
    },
    Auth = {
        verificationConnection = nil,
        lastCheck = 0,
        checkInterval = 50
    },
    Friends = {}
}
-- ==========================================
-- UTILIDADES
-- ==========================================
local Utils = {}
function Utils.SafeCall(func, ...)
    local success, result = pcall(func, ...)
    if not success then
        warn("[DN Menu] Error:", result)
        return false, result
    end
    return true, result
end
function Utils.GetCharacter(player)
    player = player or LocalPlayer
    return player and player.Character
end
function Utils.GetHumanoid(player)
    local char = Utils.GetCharacter(player)
    return char and char:FindFirstChildOfClass("Humanoid")
end
function Utils.GetRootPart(player)
    local char = Utils.GetCharacter(player)
    return char and char:FindFirstChild("HumanoidRootPart")
end
function Utils.GetDistance(pos1, pos2)
    if not pos1 or not pos2 then return math.huge end
    return (pos1 - pos2).Magnitude
end
function Utils.ClearConnections(tbl)
    if type(tbl) ~= "table" then return end
    for i, conn in ipairs(tbl) do
        if conn and typeof(conn) == "RBXScriptConnection" then
            Utils.SafeCall(function() conn:Disconnect() end)
        end
        tbl[i] = nil
    end
end
function Utils.IsMobile()
    return Services.UserInputService.TouchEnabled and not Services.UserInputService.KeyboardEnabled
end
-- ==========================================
-- SISTEMA A-CHASSIS - FUNÇÕES PRINCIPAIS
-- ==========================================
function Utils.IsAChassis(model)
    if not model or not model:IsA("Model") then return false end
    return model:FindFirstChild("A-Chassis Tune", true) ~= nil
end
function Utils.UpdateVehicleCache(force)
    local currentTime = tick()
    if not force and currentTime - State.Vehicles.lastCacheUpdate < State.Vehicles.cacheUpdateInterval then return end
    State.Vehicles.lastCacheUpdate = currentTime
    local vehicles = {}
    local processed = {}
    for _, obj in ipairs(Services.Workspace:GetChildren()) do -- Reduzir escopo para GetChildren em vez de GetDescendants
        if obj:IsA("Model") and not processed[obj] and Utils.IsAChassis(obj) then
            table.insert(vehicles, obj)
            processed[obj] = true
        end
    end
    State.Vehicles.cache = vehicles
end
function Utils.GetAllAChassis()
    Utils.UpdateVehicleCache()
    return State.Vehicles.cache
end
function Utils.FindAChassisVehicle(vehicleName)
    Utils.UpdateVehicleCache()
    for _, vehicle in ipairs(State.Vehicles.cache) do
        if vehicle.Name == vehicleName or vehicle.Name:match(vehicleName) then
            return vehicle
        end
    end
    return nil
end
function Utils.GetVehicleMainPart(vehicle)
    if not vehicle then return nil end
    local vehicleSeat = vehicle:FindFirstChild("VehicleSeat", true)
    if vehicleSeat then return vehicleSeat end
    local driveSeat = vehicle:FindFirstChild("DriveSeat", true)
    if driveSeat then return driveSeat end
    for _, obj in ipairs(vehicle:GetChildren()) do -- Otimizado para GetChildren
        if obj:IsA("VehicleSeat") or obj:IsA("Seat") then
            return obj
        end
    end
    return vehicle:FindFirstChildWhichIsA("BasePart", true)
end
function Utils.GetNearestVehicle()
    local hrp = Utils.GetRootPart()
    if not hrp then return nil end
    local minDist = math.huge
    local nearest = nil
    Utils.UpdateVehicleCache()
    for _, vehicle in ipairs(State.Vehicles.cache) do
        local main = Utils.GetVehicleMainPart(vehicle)
        if main then
            local dist = Utils.GetDistance(hrp.Position, main.Position)
            if dist < minDist then
                minDist = dist
                nearest = vehicle
            end
        end
    end
    return nearest
end
-- ==========================================
-- MÓDULO JOGADOR
-- ==========================================
local PlayerModule = {}
function PlayerModule.ActivateSpeed(enabled)
    local feature = State.Features.Speed
    feature.active = enabled
    if enabled then
        if feature.connection then return end
        feature.connection = Services.RunService.Heartbeat:Connect(function()
            local humanoid = Utils.GetHumanoid()
            if humanoid then
                humanoid.WalkSpeed = feature.value
            end
        end)
    else
        if feature.connection then
            feature.connection:Disconnect()
            feature.connection = nil
        end
        local humanoid = Utils.GetHumanoid()
        if humanoid then
            humanoid.WalkSpeed = 16 -- Reset to default
        end
    end
end
function PlayerModule.SetSpeed(value)
    State.Features.Speed.value = value
end
function PlayerModule.ActivateJumpPower(enabled)
    local feature = State.Features.JumpPower
    feature.active = enabled
    if enabled then
        if feature.connection then return end
        feature.connection = Services.RunService.Heartbeat:Connect(function()
            local humanoid = Utils.GetHumanoid()
            if humanoid then
                humanoid.JumpPower = feature.value
            end
        end)
    else
        if feature.connection then
            feature.connection:Disconnect()
            feature.connection = nil
        end
        local humanoid = Utils.GetHumanoid()
        if humanoid then
            humanoid.JumpPower = 50 -- Reset to default
        end
    end
end
function PlayerModule.SetJumpPower(value)
    State.Features.JumpPower.value = value
end
function PlayerModule.ActivateGodmode(enabled)
    -- Função vazia - mantida para compatibilidade com toggle locked
end
function PlayerModule.ActivateNoclip(enabled)
    local feature = State.Features.Noclip
    feature.active = enabled
    if enabled then
        local lastNoclipUpdate = 0
        feature.connection = Services.RunService.Stepped:Connect(function()
            if tick() - lastNoclipUpdate < 0.15 then return end
            lastNoclipUpdate = tick()
            local char = Utils.GetCharacter()
            if char then
                for _, part in ipairs(char:GetChildren()) do -- Otimizado
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end
            end
        end)
    else
        if feature.connection then
            feature.connection:Disconnect()
            feature.connection = nil
        end
    end
end
function PlayerModule.ActivateSoloSession(enabled)
    -- Função vazia - mantida para compatibilidade com toggle locked
end
function PlayerModule.SetCameraFOV(value)
    State.Features.CameraFOV = value
    if workspace.CurrentCamera then
        workspace.CurrentCamera.FieldOfView = value
    end
end


-- ==========================================
-- MÓDULO VISUAL - EXUNYS ESP COMPLETO E CORRIGIDO
-- ==========================================
local VisualModule = {}

function VisualModule.LoadESP()
    if State.Features.ESP.loaded then
        return true, "ESP já carregado"
    end
   
    local success, err = pcall(function()
        -- Configurações básicas
        ExunysDeveloperESP.Settings.Enabled = false
        ExunysDeveloperESP.Settings.TeamCheck = false
        ExunysDeveloperESP.Settings.AliveCheck = true
        ExunysDeveloperESP.Settings.LoadConfigOnLaunch = false
        ExunysDeveloperESP.Settings.PartsOnly = false
        
        -- CRÍTICO: Self ESP e Visible Check
        ExunysDeveloperESP.Settings.SelfESP = State.Features.ESP.selfESP
        ExunysDeveloperESP.Settings.VisibleCheck = State.Features.ESP.visibleCheck
        
        -- Configuração da Box
        ExunysDeveloperESP.Properties.Box.Enabled = true
        ExunysDeveloperESP.Properties.Box.Color = State.Features.ESP.boxColor
        ExunysDeveloperESP.Properties.Box.VisibleColor = State.Features.ESP.boxColor
        ExunysDeveloperESP.Properties.Box.InvisibleColor = State.Features.ESP.invisibleBoxColor
        ExunysDeveloperESP.Properties.Box.Thickness = 2
        ExunysDeveloperESP.Properties.Box.Transparency = 1
        ExunysDeveloperESP.Properties.Box.Filled = false
        ExunysDeveloperESP.Properties.Box.Outline = true
        ExunysDeveloperESP.Properties.Box.OutlineColor = Color3.fromRGB(0, 0, 0)
        
        -- DESATIVAR TRACERS (linhas conectando)
        ExunysDeveloperESP.Properties.Tracer.Enabled = false
        ExunysDeveloperESP.Properties.Tracer.From = "Bottom"
        ExunysDeveloperESP.Properties.Tracer.Color = Color3.fromRGB(255, 255, 255)
        ExunysDeveloperESP.Properties.Tracer.Thickness = 1
        ExunysDeveloperESP.Properties.Tracer.Transparency = 1
        
        -- Configuração de Chams
        ExunysDeveloperESP.Properties.Chams.Enabled = false
        ExunysDeveloperESP.Properties.Chams.Color = State.Features.Chams.fillColor
        ExunysDeveloperESP.Properties.Chams.Transparency = 0.5
        ExunysDeveloperESP.Properties.Chams.Wireframe = false
        
        -- Configuração de texto/nome
        ExunysDeveloperESP.Properties.Name.Enabled = true
        ExunysDeveloperESP.Properties.Name.Color = State.Features.ESP.color
        ExunysDeveloperESP.Properties.Name.Outline = true
        ExunysDeveloperESP.Properties.Name.OutlineColor = Color3.fromRGB(0, 0, 0)
        
        -- Distância
        ExunysDeveloperESP.Properties.Distance.Enabled = true
        ExunysDeveloperESP.Properties.Distance.Color = State.Features.ESP.color
        ExunysDeveloperESP.Properties.Distance.Outline = true
        ExunysDeveloperESP.Properties.Distance.OutlineColor = Color3.fromRGB(0, 0, 0)
        
        -- Health bar
        ExunysDeveloperESP.Properties.HealthBar.Enabled = true
        ExunysDeveloperESP.Properties.HealthBar.Outline = true
        ExunysDeveloperESP.Properties.HealthBar.OutlineColor = Color3.fromRGB(0, 0, 0)
        
        -- INICIAR O ESP
        ExunysDeveloperESP()
        
        State.Features.ESP.loaded = true
    end)

    if not success then
        warn("[DN Menu] Erro ao carregar ESP:", err)
        return false, err
    end
    
    return true, "ESP carregado com sucesso"
end

function VisualModule.ActivateESP(enabled)
    if not State.Features.ESP.loaded then
        return
    end
    
    State.Features.ESP.active = enabled
    ExunysDeveloperESP.Settings.Enabled = enabled
end

function VisualModule.UpdateESPColor(color)
    State.Features.ESP.color = color
    if State.Features.ESP.loaded then
        pcall(function()
            ExunysDeveloperESP.Properties.Name.Color = color
            ExunysDeveloperESP.Properties.Distance.Color = color
        end)
    end
end

function VisualModule.UpdateBoxColor(color)
    State.Features.ESP.boxColor = color
    if State.Features.ESP.loaded then
        pcall(function()
            ExunysDeveloperESP.Properties.Box.Color = color
            ExunysDeveloperESP.Properties.Box.VisibleColor = color
        end)
    end
end

function VisualModule.UpdateInvisibleBoxColor(color)
    State.Features.ESP.invisibleBoxColor = color
    if State.Features.ESP.loaded then
        pcall(function()
            ExunysDeveloperESP.Properties.Box.InvisibleColor = color
        end)
    end
end

function VisualModule.UpdateSelfESP(enabled)
    State.Features.ESP.selfESP = enabled
    if State.Features.ESP.loaded then
        pcall(function()
            ExunysDeveloperESP.Settings.SelfESP = enabled
            
            -- Forçar atualização
            if ExunysDeveloperESP.Unload then
                ExunysDeveloperESP:Unload()
                task.wait(0.1)
                ExunysDeveloperESP()
            end
        end)
    end
end

function VisualModule.UpdateVisibleCheck(enabled)
    State.Features.ESP.visibleCheck = enabled
    if State.Features.ESP.loaded then
        pcall(function()
            ExunysDeveloperESP.Settings.VisibleCheck = enabled
        end)
    end
end

function VisualModule.ToggleTracers(enabled)
    if State.Features.ESP.loaded then
        pcall(function()
            ExunysDeveloperESP.Properties.Tracer.Enabled = enabled
        end)
    end
end

function VisualModule.ActivateChams(enabled)
    State.Features.Chams.active = enabled
    if State.Features.ESP.loaded then
        pcall(function()
            ExunysDeveloperESP.Properties.Chams.Enabled = enabled
            ExunysDeveloperESP.Properties.Chams.Color = State.Features.Chams.fillColor
            ExunysDeveloperESP.Properties.Chams.Transparency = 0.5
        end)
    end
end

function VisualModule.UpdateChamsColors()
    if State.Features.ESP.loaded and State.Features.Chams.active then
        pcall(function()
            ExunysDeveloperESP.Properties.Chams.Color = State.Features.Chams.fillColor
        end)
    end
end

function VisualModule.ActivateFullbright(enabled)
    local feature = State.Features.Fullbright
    feature.active = enabled
    if enabled then
        feature.original = {
            Brightness = Services.Lighting.Brightness,
            ClockTime = Services.Lighting.ClockTime,
            FogEnd = Services.Lighting.FogEnd,
            GlobalShadows = Services.Lighting.GlobalShadows,
            OutdoorAmbient = Services.Lighting.OutdoorAmbient
        }
        Services.Lighting.Brightness = 2
        Services.Lighting.ClockTime = 14
        Services.Lighting.FogEnd = 100000
        Services.Lighting.GlobalShadows = false
        Services.Lighting.OutdoorAmbient = Color3.fromRGB(128, 128, 128)
    else
        if feature.original.Brightness then
            Services.Lighting.Brightness = feature.original.Brightness
            Services.Lighting.ClockTime = feature.original.ClockTime
            Services.Lighting.FogEnd = feature.original.FogEnd
            Services.Lighting.GlobalShadows = feature.original.GlobalShadows
            Services.Lighting.OutdoorAmbient = feature.original.OutdoorAmbient
        end
    end
end

function VisualModule.ActivateCarESP(enabled)
    if not State.Features.ESP.loaded then return end
    
    State.Features.CarESP.active = enabled
    
    if enabled then
        Utils.UpdateVehicleCache(true)
        
        for _, vehicle in ipairs(State.Vehicles.cache) do
            local chassis = vehicle:FindFirstChild("Chassis")
            if chassis then
                pcall(function()
                    ExunysDeveloperESP:WrapObject(
                        chassis,
                        vehicle.Name,
                        {ESP = true, Box = true, Tracer = false},
                        300
                    )
                end)
            end
        end
    else
        pcall(function()
            for Hash, entry in pairs(ExunysDeveloperESP.UtilityAssets.WrappedObjects or {}) do
                if not entry.IsAPlayer then
                    ExunysDeveloperESP:UnwrapObject(nil, Hash)
                end
            end
        end)
    end
end
-- =================================
-- MÓDULO EXPLOIT - OTIMIZADO
-- ==========================================
local ExploitModule = {}
function ExploitModule.AddFriend(playerName)
    if not table.find(State.Friends, playerName) then
        table.insert(State.Friends, playerName)
    end
end
function ExploitModule.RemoveFriend(playerName)
    for i, name in ipairs(State.Friends) do
        if name == playerName then
            table.remove(State.Friends, i)
            break
        end
    end
end
function ExploitModule.ActivateGunPull(enabled)
    local feature = State.Features.GunPull
    feature.active = enabled
    if enabled then
        if feature.connection then return end
        feature.connection = Services.RunService.Heartbeat:Connect(function()
            if not feature.active then
                Utils.ClearConnections({feature.connection})
                feature.connection = nil
                return
            end
            local currentTime = tick()
            if currentTime - feature.lastPull < feature.pullRate then return end
            feature.lastPull = currentTime
            Utils.SafeCall(function()
                for _, player in ipairs(Services.Players:GetPlayers()) do
                    if player ~= LocalPlayer and player:FindFirstChild("Backpack") then
                        for _, item in ipairs(player.Backpack:GetChildren()) do
                            if item:IsA("Tool") and item:FindFirstChild("ACS_Settings") and item.ACS_Settings:IsA("ModuleScript") then
                                item.Parent = LocalPlayer.Backpack
                            end
                        end
                    end
                end
            end)
        end)
    else
        Utils.ClearConnections({feature.connection})
        feature.connection = nil
    end
end
function ExploitModule.ActivateExorcismo(enabled)
    local feature = State.Features.Exorcismo
    feature.active = enabled
    if enabled then
        if feature.connection then return end
        local function onCharacterAdded(character)
            if not feature.active then return end
            task.wait(0.1)
            local humanoid = character and character:FindFirstChildOfClass("Humanoid")
            if not humanoid or humanoid.RigType ~= Enum.HumanoidRigType.R15 then return end
            local animateScript = character:FindFirstChild("Animate")
            if not animateScript then return end
            -- save original once
            if not feature.originalAnimateScript then
                feature.originalAnimateScript = animateScript:Clone()
            end
            -- backup current AnimationIds
            feature.backupAnimations = {}
            for _, folder in ipairs(animateScript:GetChildren()) do
                if folder and folder:IsA("Instance") then
                    for _, anim in ipairs(folder:GetChildren()) do
                        if anim and anim:IsA("Animation") then
                            feature.backupAnimations[folder.Name .. "_" .. anim.Name] = anim.AnimationId
                        end
                    end
                end
            end
            -- safe set helper
            local function safeSet(folderName, animName, newId)
                local f = animateScript:FindFirstChild(folderName)
                if f then
                    local a = f:FindFirstChild(animName)
                    if a and a:IsA("Animation") then
                        pcall(function() a.AnimationId = newId end)
                    end
                end
            end
            -- set replacement animation IDs (example IDs kept from original)
            pcall(function()
                safeSet("idle","Animation1","http://www.roblox.com/asset/?id=80103653497738")
                safeSet("idle","Animation2","http://www.roblox.com/asset/?id=75794256017298")
                safeSet("walk","WalkAnim","http://www.roblox.com/asset/?id=88508412373927")
                safeSet("run","RunAnim","http://www.roblox.com/asset/?id=88508412373927")
            end)
            -- stop currently playing tracks to allow changes to take effect
            local animator = humanoid:FindFirstChild("Animator")
            if animator then
                for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
                    pcall(function() track:Stop(0) end)
                end
            end
        end
        -- run on current character and hook future characters
        if LocalPlayer and LocalPlayer.Character then
            onCharacterAdded(LocalPlayer.Character)
        end
        feature.connection = LocalPlayer.CharacterAdded:Connect(onCharacterAdded)
    else
        -- disable: disconnect and restore original animate if available
        if feature.connection then
            pcall(function() feature.connection:Disconnect() end)
            feature.connection = nil
        end
        if LocalPlayer and LocalPlayer.Character and feature.originalAnimateScript then
            local char = LocalPlayer.Character
            -- safely remove current modified Animate
            local currentAnimate = char:FindFirstChild("Animate")
            if currentAnimate then
                pcall(function() currentAnimate:Destroy() end)
            end
            -- restore cloned original and reapply backed up ids
            local newAnimate = feature.originalAnimateScript:Clone()
            for key, animId in pairs(feature.backupAnimations or {}) do
                local folderName, animName = key:match("(.+)_(.+)")
                if folderName and animName then
                    local folder = newAnimate:FindFirstChild(folderName)
                    if folder then
                        local anim = folder:FindFirstChild(animName)
                        if anim and anim:IsA("Animation") then
                            pcall(function() anim.AnimationId = animId end)
                        end
                    end
                end
            end
            newAnimate.Parent = char
            -- ensure animator restarts normally
            task.wait(0.2)
            feature.backupAnimations = {}
        end
    end
end
function ExploitModule.ActivateBangPlayer(enabled)
    local feature = State.Features.BangPlayer
    feature.active = enabled
    if enabled then
        if not feature.target or not feature.target.Character then
            feature.active = false
            return
        end
        if feature.connection then return end
        local lastToggle = 0
        feature.connection = Services.RunService.Heartbeat:Connect(function()
            if not feature.active then
                Utils.ClearConnections({feature.connection})
                feature.connection = nil
                return
            end
            local currentTime = tick()
            if currentTime - lastToggle < feature.bangSpeed then return end
            lastToggle = currentTime
            Utils.SafeCall(function()
                local myHRP = Utils.GetRootPart()
                local targetHRP = Utils.GetRootPart(feature.target)
                if myHRP and targetHRP then
                    local targetCFrame = targetHRP.CFrame
                    local behindOffset = -targetCFrame.LookVector * 3
                    local bangOffset = targetCFrame.LookVector * (feature.isMovingBack and -feature.bangDistance or feature.bangDistance)
                    local finalPosition = targetCFrame.Position + behindOffset + bangOffset
                    myHRP.CFrame = CFrame.new(
                        finalPosition,
                        finalPosition + targetCFrame.LookVector
                    )
                    feature.isMovingBack = not feature.isMovingBack
                end
            end)
        end)
    else
        Utils.ClearConnections({feature.connection})
        feature.connection = nil
        feature.isMovingBack = false
    end
end
function ExploitModule.ActivateVehicleLauncher(enabled)
    local feature = State.Features.VehicleLauncher
    feature.active = enabled
    if enabled then
        local mouse = LocalPlayer:GetMouse()
        local function clearVehicle()
            if feature.alignPosition then
                feature.alignPosition:Destroy()
                feature.alignPosition = nil
            end
            if feature.alignOrientation then
                feature.alignOrientation:Destroy()
                feature.alignOrientation = nil
            end
            if feature.attachment0 then
                feature.attachment0:Destroy()
                feature.attachment0 = nil
            end
            if feature.attachment1 then
                feature.attachment1:Destroy()
                feature.attachment1 = nil
            end
            if feature.animTrack then
                feature.animTrack:Stop()
                feature.animTrack = nil
            end
            feature.selectedVehicle = nil
            feature.holding = false
        end
        mouse.Button1Down:Connect(function()
            if not feature.active then return end
            local target = mouse.Target
            if not target then return end
            local vehicle = target
            while vehicle and vehicle ~= Services.Workspace do
                if vehicle:IsA("Model") and Utils.IsAChassis(vehicle) then
                    break
                end
                vehicle = vehicle.Parent
            end
            if not vehicle or not Utils.IsAChassis(vehicle) then
                return
            end
            if vehicle.Name:lower():find("moto") then
                return
            end
            if feature.holding and feature.selectedVehicle == vehicle then
                return
            end
            clearVehicle()
            feature.selectedVehicle = vehicle
            feature.holding = true
            local mainPart = Utils.GetVehicleMainPart(vehicle)
            if not mainPart then return end
            local hrp = Utils.GetRootPart()
            if not hrp then return end
            -- Removido anchoring para evitar bugs e lag
            feature.attachment0 = Instance.new("Attachment")
            feature.attachment0.Parent = mainPart
            feature.attachment1 = Instance.new("Attachment")
            feature.attachment1.Parent = hrp
            feature.alignPosition = Instance.new("AlignPosition")
            feature.alignPosition.Attachment0 = feature.attachment0
            feature.alignPosition.Attachment1 = feature.attachment1
            feature.alignPosition.MaxForce = 9e9
            feature.alignPosition.MaxVelocity = math.huge
            feature.alignPosition.Responsiveness = 200
            feature.alignPosition.Parent = mainPart
            feature.alignOrientation = Instance.new("AlignOrientation")
            feature.alignOrientation.Attachment0 = feature.attachment0
            feature.alignOrientation.Attachment1 = feature.attachment1
            feature.alignOrientation.MaxTorque = 9e9
            feature.alignOrientation.Responsiveness = 200
            feature.alignOrientation.Parent = mainPart
            local humanoid = Utils.GetHumanoid()
            if humanoid then
                if feature.animTrack then
                    feature.animTrack:Stop()
                end
                local animation = Instance.new("Animation")
                animation.AnimationId = "rbxassetid://2510198475" -- Hands up animation (FE compatible)
                local animator = humanoid:FindFirstChildOfClass("Animator")
                if animator then
                    feature.animTrack = animator:LoadAnimation(animation)
                    feature.animTrack:Play()
                end
            end
        end)
        Services.UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if gameProcessed or not feature.active or not feature.selectedVehicle or not feature.holding then return end
            if input.KeyCode == Enum.KeyCode.Y then
                local hrp = Utils.GetRootPart()
                if not hrp then return end
                local mainPart = Utils.GetVehicleMainPart(feature.selectedVehicle)
                if not mainPart then return end
                -- Removido unanchoring desnecessário
                if feature.alignPosition then
                    feature.alignPosition:Destroy()
                    feature.alignPosition = nil
                end
                if feature.alignOrientation then
                    feature.alignOrientation:Destroy()
                    feature.alignOrientation = nil
                end
                if feature.attachment0 then
                    feature.attachment0:Destroy()
                    feature.attachment0 = nil
                end
                if feature.attachment1 then
                    feature.attachment1:Destroy()
                    feature.attachment1 = nil
                end
                local camera = Services.Workspace.CurrentCamera
                local launchDirection = camera.CFrame.LookVector
                local launchForce = Instance.new("BodyVelocity")
                launchForce.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                launchForce.Velocity = launchDirection * 350
                launchForce.Parent = mainPart
                task.delay(0.3, function()
                    if launchForce and launchForce.Parent then
                        launchForce:Destroy()
                    end
                end)
                if feature.animTrack then
                    feature.animTrack:Stop()
                    feature.animTrack = nil
                end
                feature.selectedVehicle = nil
                feature.holding = false
            end
        end)
        feature.connection = Services.RunService.Heartbeat:Connect(function()
            if not feature.active then
                clearVehicle()
                Utils.ClearConnections({feature.connection})
                feature.connection = nil
                return
            end
            if feature.selectedVehicle and feature.holding and feature.attachment1 then
                local hrp = Utils.GetRootPart()
                if not hrp then return end
                local mainPart = Utils.GetVehicleMainPart(feature.selectedVehicle)
                if not mainPart then
                    clearVehicle()
                    return
                end
                local upOffset = Vector3.new(0, 5, 0)
                local frontOffset = hrp.CFrame.LookVector * 0
                feature.attachment1.WorldPosition = hrp.Position + upOffset + frontOffset
                feature.attachment1.WorldCFrame = hrp.CFrame * CFrame.new(0, 5, 0)
            end
        end)
    else
        clearVehicle()
        Utils.ClearConnections({feature.connection})
        feature.connection = nil
    end
end
function ExploitModule.ActivateAutoUnlock(enabled)
    local feature = State.Features.AutoUnlock
    feature.active = enabled
    if enabled then
        feature.connection = Services.RunService.Heartbeat:Connect(function()
            if not feature.active then return end
            local currentTime = tick()
            if currentTime - feature.lastUnlock < feature.unlockRate then return end
            feature.lastUnlock = currentTime
            VehicleModule.UnlockAllVehicles()
        end)
    else
        if feature.connection then
            feature.connection:Disconnect()
            feature.connection = nil
        end
    end
end
function ExploitModule.ActivateVehicleDelete(enabled)
    local feature = State.Features.VehicleDelete
    feature.active = enabled
    if enabled then
        local mouse = LocalPlayer:GetMouse()
        feature.connection = mouse.Button1Down:Connect(function()
            if not feature.active then return end
            local target = mouse.Target
            if not target then return end
            local vehicle = target
            while vehicle and vehicle ~= Services.Workspace do
                if vehicle:IsA("Model") and Utils.IsAChassis(vehicle) then
                    break
                end
                vehicle = vehicle.Parent
            end
            if not vehicle then return end
            -- Use telekinesis logic to move model under ground
            local tool = LocalPlayer.Backpack:FindFirstChild("Telekinesis V6") or LocalPlayer.Character:FindFirstChild("Telekinesis V6")
            if not tool then
                loadstring(game:HttpGet(Config.externos.Telekinesis))()
                task.wait(0.5)
                tool = LocalPlayer.Backpack:FindFirstChild("Telekinesis V6")
            end
            if tool then
                tool.Parent = LocalPlayer.Character
                task.wait(0.1)
                -- Simulate telekinesis to move under ground
                local mainPart = Utils.GetVehicleMainPart(vehicle)
                if mainPart then
                    mainPart.CFrame = mainPart.CFrame * CFrame.new(0, -1000, 0)
                end
                tool.Parent = LocalPlayer.Backpack
            end
        end)
    else
        if feature.connection then
            feature.connection:Disconnect()
            feature.connection = nil
        end
    end
end
function ExploitModule.TeleportToNearestVehicle()
    local vehicle = Utils.GetNearestVehicle()
    if not vehicle then return end
    local main = Utils.GetVehicleMainPart(vehicle)
    if main and main:IsA("VehicleSeat") then
        local hrp = Utils.GetRootPart()
        if hrp then
            hrp.CFrame = main.CFrame * CFrame.new(0, 3, 0)
            task.wait(0.1)
            main:Sit(Utils.GetHumanoid())
        end
    end
end
do
    local BV_NAME = "DNMenu_VehicleFly_BV"
    local ATTACH_PREFIX = "DNMenu_VehicleFly_Attach"
    local ALIGN_POS_NAME = "DNMenu_AlignPos"
    local ALIGN_ORI_NAME = "DNMenu_AlignOri"
    local function createBV(part)
        if not part or not part:IsA("BasePart") then return nil end
        local existing = part:FindFirstChild(BV_NAME)
        if existing then pcall(function() existing:Destroy() end) end
        local bv = Instance.new("BodyVelocity")
        bv.Name = BV_NAME
        bv.MaxForce = Vector3.new(9e9, 9e9, 9e9)
        bv.P = 1250
        bv.Velocity = Vector3.new(0,0,0)
        bv.Parent = part
        return bv
    end
    local function createAligns(targetPart, attachmentTarget)
        -- targetPart: BasePart to attach Aligns to (usually HRP or vehicle main)
        -- attachmentTarget: BasePart to which attachments will point (vehicle main or nil)
        if not targetPart or not targetPart:IsA("BasePart") then return nil end
        -- cleanup existing aligns/attachments if any
        local existingAP = targetPart:FindFirstChild(ALIGN_POS_NAME)
        if existingAP then pcall(function() existingAP:Destroy() end) end
        local existingAO = targetPart:FindFirstChild(ALIGN_ORI_NAME)
        if existingAO then pcall(function() existingAO:Destroy() end) end
        -- attachments on targetPart
        local att0 = Instance.new("Attachment")
        att0.Name = ATTACH_PREFIX.."_0"
        att0.Parent = targetPart
        local att1 = Instance.new("Attachment")
        att1.Name = ATTACH_PREFIX.."_1"
        if attachmentTarget and attachmentTarget:IsA("BasePart") then
            att1.Parent = attachmentTarget
        else
            att1.Parent = targetPart
        end
        -- AlignPosition
        local alignPos = Instance.new("AlignPosition")
        alignPos.Name = ALIGN_POS_NAME
        alignPos.Attachment0 = att0
        alignPos.Attachment1 = att1
        alignPos.MaxForce = 9e9
        alignPos.Responsiveness = 50
        alignPos.RigidityEnabled = true
        alignPos.Parent = targetPart
        -- AlignOrientation
        local alignOri = Instance.new("AlignOrientation")
        alignOri.Name = ALIGN_ORI_NAME
        alignOri.Attachment0 = att0
        alignOri.Attachment1 = att1
        alignOri.MaxTorque = 9e9
        alignOri.Responsiveness = 50
        alignOri.Parent = targetPart
        return {att0 = att0, att1 = att1, alignPos = alignPos, alignOri = alignOri}
    end
    function ExploitModule.ActivateVehicleFly(enabled)
        local feature = State.Features.VehicleFly
        feature.active = enabled
        if enabled then
            if feature.connection then return end
            feature.active = true
            -- attempt to attach to nearest A-Chassis vehicle
            local vehicle = Utils.FindAChassisVehicle(nil) or Utils.GetNearestVehicle()
            local mainPart = vehicle and Utils.GetVehicleMainPart(vehicle)
            if mainPart and mainPart:IsA("BasePart") and vehicle then
                -- attach Aligns to vehicle main part (apply aligns to HRP to follow vehicle or apply to vehicle itself)
                -- prefer to move the vehicle main part directly for smoother vehicle fly
                -- create aligns on mainPart.Parent PrimaryPart (or mainPart itself)
                local targetPart = mainPart
                -- create aligns on targetPart to control its position/orientation
                local aligns = createAligns(targetPart, targetPart)
                feature.aligns = aligns
                -- store which part we're controlling
                feature.controlledPart = targetPart
            else
                -- fallback: use BodyVelocity on player HRP
                local hrp = Utils.GetRootPart()
                if hrp then
                    feature.bodyVelocity = createBV(hrp)
                    feature.controlledPart = hrp
                else
                    warn("[DN Menu] VehicleFly: nenhum HRP encontrado para fallback.")
                end
            end
            -- Heartbeat loop to update velocity/move
            feature.connection = Utils.AddConnection(Services.RunService.Heartbeat:Connect(function()
                if not feature.active then return end
                local cam = Services.Workspace.CurrentCamera
                if not cam then return end
                local speed = feature.speed or 50
                local mv = Vector3.new(0,0,0)
                local w = Services.UserInputService:IsKeyDown(Enum.KeyCode.W)
                local s = Services.UserInputService:IsKeyDown(Enum.KeyCode.S)
                local a = Services.UserInputService:IsKeyDown(Enum.KeyCode.A)
                local d = Services.UserInputService:IsKeyDown(Enum.KeyCode.D)
                local spc = Services.UserInputService:IsKeyDown(Enum.KeyCode.Space)
                local lshift = Services.UserInputService:IsKeyDown(Enum.KeyCode.LeftShift)
                if w then mv = mv + cam.CFrame.LookVector end
                if s then mv = mv - cam.CFrame.LookVector end
                if a then mv = mv - cam.CFrame.RightVector end
                if d then mv = mv + cam.CFrame.RightVector end
                if spc then mv = mv + Vector3.new(0,1,0) end
                if lshift then mv = mv - Vector3.new(0,1,0) end
                if mv.Magnitude > 0 then mv = mv.Unit * speed else mv = Vector3.new(0,0,0) end
                -- if using aligns, set target positions by moving Attachment1 via CFrame (Aligns will try to match)
                if feature.aligns and feature.controlledPart and feature.aligns.att1 and feature.aligns.att0 then
                    -- compute desired world position
                    local current = feature.controlledPart.CFrame
                    local desired = current + mv * Services.RunService.Heartbeat:Wait() -- small predictive step
                    -- apply by moving the attachment on the parent to the desired CFrame (if att1 is on same part, move att0 instead)
                    -- simpler: set the AlignPosition/Orientation properties via attachments' world position (approx)
                    pcall(function()
                        feature.aligns.att1.WorldPosition = desired.Position
                        feature.aligns.att1.WorldOrientation = desired - desired.Position -- assign via CFrame? property may not exist; fallback below
                    end)
                    -- Note: If direct WorldPosition/WorldOrientation isn't supported on the executor, fallback to setting BodyVelocity
                    if feature.bodyVelocity and feature.bodyVelocity.Parent then
                        feature.bodyVelocity.Velocity = mv
                    end
                else
                    if feature.bodyVelocity and feature.bodyVelocity.Parent then
                        feature.bodyVelocity.Velocity = mv
                    end
                end
            end))
        else
            -- disable: cleanup aligns, BV and connection
            feature.active = false
            if feature.connection then pcall(function() feature.connection:Disconnect() end) end
            feature.connection = nil
            if feature.bodyVelocity and feature.bodyVelocity.Parent then pcall(function() feature.bodyVelocity:Destroy() end) end
            feature.bodyVelocity = nil
            if feature.aligns then
                pcall(function()
                    if feature.aligns.alignPos then feature.aligns.alignPos:Destroy() end
                    if feature.aligns.alignOri then feature.aligns.alignOri:Destroy() end
                    if feature.aligns.att0 then feature.aligns.att0:Destroy() end
                    if feature.aligns.att1 then feature.aligns.att1:Destroy() end
                end)
                feature.aligns = nil
            end
            -- reset physics on controlled part (HRP or vehicle part)
            if feature.controlledPart and feature.controlledPart:IsA("BasePart") then
                pcall(function()
                    feature.controlledPart.Velocity = Vector3.new(0,0,0)
                    feature.controlledPart.RotVelocity = Vector3.new(0,0,0)
                end)
                feature.controlledPart = nil
            end
        end
    end
end
function ExploitModule.ActivateVehicleNoclip(enabled)
    local feature = State.Features.VehicleNoclip
    feature.active = enabled
    if enabled then
        feature.connection = Services.RunService.Stepped:Connect(function()
            local currentTime = tick()
            if currentTime - (feature.lastUpdate or 0) < 0.1 then return end
            feature.lastUpdate = currentTime
            local humanoid = Utils.GetHumanoid()
            if not humanoid or not humanoid.SeatPart then return end
            local vehicle = humanoid.SeatPart.Parent
            for _, part in ipairs(vehicle:GetChildren()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end)
    else
        if feature.connection then
            feature.connection:Disconnect()
            feature.connection = nil
        end
    end
end



function ExploitModule.KillAllServer()
    local hrp = Utils.GetRootPart()
    if not hrp then return end
    local front = hrp.CFrame * CFrame.new(0, 0, -5)
    for _, player in ipairs(Services.Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local pChar = player.Character
            if pChar then
                local pHead = pChar:FindFirstChild("Head")
                if pHead then
                    pHead.Anchored = true
                    pHead.CFrame = front * CFrame.new(math.random(-5,5), 0, math.random(-5,5))
                end
            end
        end
    end
end
-- ==========================================
-- MÓDULO VEÍCULO - SISTEMA A-CHASSIS
-- ==========================================
local VehicleModule = {}
function VehicleModule.UnlockAllVehicles()
    local count = 0
    local hrp = Utils.GetRootPart()
    if not hrp then return 0 end
    Utils.SafeCall(function()
        Utils.UpdateVehicleCache(true)
        for _, vehicle in ipairs(State.Vehicles.cache) do
            for _, obj in ipairs(vehicle:GetDescendants()) do
                if obj:IsA("VehicleSeat") and obj.Disabled then
                    local dist = Utils.GetDistance(hrp.Position, obj.Position)
                    if dist <= State.Vehicles.unlockRange then
                        obj.Disabled = false
                        count = count + 1
                    end
                end
            end
        end
    end)
    return count
end
function VehicleModule.SetUnlockRange(value)
    State.Vehicles.unlockRange = value
end

function ExploitModule.VehicleRain()
    local player = State.Players.selected
    if not player then 
        return false, "Selecione um jogador primeiro"
    end
    
    local targetHRP = Utils.GetRootPart(player)
    if not targetHRP then return false, "Jogador inválido" end
    
    local telekinesisTool = LocalPlayer.Backpack:FindFirstChild("Telekinesis V6")
    if not telekinesisTool then
        loadstring(game:HttpGet(Config.externos.Telekinesis))()
        task.wait(0.5)
        telekinesisTool = LocalPlayer.Backpack:FindFirstChild("Telekinesis V6")
    end
    
    if not telekinesisTool then return false, "Telecinese não disponível" end
    
    telekinesisTool.Parent = LocalPlayer.Character
    task.wait(0.2)
    
    local myHRP = Utils.GetRootPart()
    if not myHRP then return false, "HRP não encontrado" end
    
    Utils.UpdateVehicleCache(true)
    local vehiclesMoved = 0
    
    for _, vehicle in ipairs(State.Vehicles.cache) do
        local driveSeat = vehicle:FindFirstChild("DriveSeat", true) or vehicle:FindFirstChild("VehicleSeat", true)
        
        if driveSeat and not driveSeat.Occupant then
            myHRP.CFrame = driveSeat.CFrame
            task.wait(0.1)
            
            local humanoid = Utils.GetHumanoid()
            if humanoid then
                driveSeat:Sit(humanoid)
                task.wait(0.1)
            end
            
            local mainPart = Utils.GetVehicleMainPart(vehicle)
            if mainPart then
                local targetPos = targetHRP.Position + Vector3.new(0, 50 + (vehiclesMoved * 10), 0)
                mainPart.CFrame = CFrame.new(targetPos)
                
                local bodyVelocity = Instance.new("BodyVelocity")
                bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                bodyVelocity.Velocity = Vector3.new(0, -50, 0)
                bodyVelocity.Parent = mainPart
                
                task.delay(2, function()
                    if bodyVelocity and bodyVelocity.Parent then
                        bodyVelocity:Destroy()
                    end
                end)
                
                vehiclesMoved = vehiclesMoved + 1
                task.wait(0.3)
            end
        end
    end
    
    telekinesisTool.Parent = LocalPlayer.Backpack
    
    return true, vehiclesMoved .. " veículo(s) lançado(s)"
end
-- ==========================================
-- MÓDULO PORTA-MALAS - SISTEMA A-CHASSIS
-- ==========================================
local PortaMalasModule = {}
function PortaMalasModule.ClearClonedTrunk()
    local count = 0
    for _, obj in ipairs(PlayerGui:GetChildren()) do
        if obj.Name == "PortaMalasClone" or obj.Name == "InvClone" then
            obj:Destroy()
            count = count + 1
        end
    end
    return count
end
function PortaMalasModule.CloneItem(itemName, vehicleName)
    if State.PortaMalas.pulling then
        return false, "Já está clonando um item!"
    end
    State.PortaMalas.pulling = true
    local success = pcall(function()
        local vehicle = Utils.FindAChassisVehicle(vehicleName)
        if vehicle and vehicle:FindFirstChild("PortaMalas") then
            local portaMalas = vehicle.PortaMalas
            for _, old in ipairs(PlayerGui:GetChildren()) do
                if old.Name == "PortaMalasClone" or old.Name == "InvClone" then
                    old:Destroy()
                end
            end
            if portaMalas:FindFirstChild("Porta-malas") then
                local portaMalasGui = portaMalas["Porta-malas"]:Clone()
                portaMalasGui.Name = "PortaMalasClone"
                portaMalasGui.Parent = PlayerGui
                portaMalasGui.Enabled = true
            end
            if portaMalas:FindFirstChild("Inv") then
                local invFolder = portaMalas.Inv:Clone()
                invFolder.Name = "InvClone"
                invFolder.Parent = PlayerGui
            end
        end
    end)
    State.PortaMalas.pulling = false
    return success, success and "Item clonado com sucesso!" or "Falha ao clonar item"
end
function PortaMalasModule.GetVehicleData()
    Utils.UpdateVehicleCache()
    local vehicleData = {}
    local usedNames = {}
    for _, vehicle in ipairs(State.Vehicles.cache) do
        if vehicle:FindFirstChild("PortaMalas") then
            local baseName = vehicle.Name
            local uniqueName = baseName
            local count = 0
            for _, name in pairs(usedNames) do
                if name == baseName then
                    count = count + 1
                elseif name:match("^" .. baseName .. "%d+$") then
                    local num = tonumber(name:match("%d+$"))
                    if num and num > count then
                        count = num
                    end
                end
            end
            if count > 0 then
                uniqueName = baseName .. (count + 1)
            end
            table.insert(usedNames, uniqueName)
            local portaMalas = vehicle.PortaMalas
            local items = {}
            if portaMalas:FindFirstChild("Inv") then
                for _, item in ipairs(portaMalas.Inv:GetChildren()) do
                    table.insert(items, item.Name)
                end
            end
            table.insert(vehicleData, {
                name = uniqueName,
                originalName = baseName,
                items = items,
                itemCount = #items
            })
        end
    end
    State.PortaMalas.vehicleData = vehicleData
    return vehicleData
end
function PortaMalasModule.StartMonitoring(updateCallback)
    if State.PortaMalas.monitorConnection then
        PortaMalasModule.StopMonitoring()
    end
    State.PortaMalas.monitorConnection = task.spawn(function()
        while true do
            task.wait(0.2) -- Atualização a cada 0.2s para reduzir lag
            if not State.PortaMalas.isRefreshing and updateCallback then
                updateCallback()
            end
        end
    end)
end
function PortaMalasModule.StopMonitoring()
    if State.PortaMalas.monitorConnection then
        task.cancel(State.PortaMalas.monitorConnection)
        State.PortaMalas.monitorConnection = nil
    end
end
-- ==========================================
-- MÓDULO COMBATE - EXUNYS AIMBOT
-- ==========================================
local CombatModule = {}

function CombatModule.LoadAimbot()
    if State.Features.Aimbot.Loaded then
        return true, "Aimbot já carregado"
    end
    
    local success, err = pcall(function()
        if Utils.IsMobile() then
            -- Mobile: usar implementação customizada
            local RunService = game:GetService("RunService")
            local UserInputService = game:GetService("UserInputService")
            local Players = game:GetService("Players")
            local Cam = workspace.CurrentCamera
            
            local FOVring = Drawing.new("Circle")
            FOVring.Visible = true
            FOVring.Thickness = 2
            FOVring.Color = State.Features.Aimbot.FOVColor
            FOVring.Filled = false
            FOVring.NumSides = 60
            FOVring.Transparency = 1
            
            local function updateFOV()
                local viewportSize = Cam.ViewportSize
                FOVring.Position = viewportSize / 2
                FOVring.Radius = State.Features.Aimbot.FOVRadius
                FOVring.Color = State.Features.Aimbot.FOVColor
            end
            
            local function smoothLookAt(target, smoothness)
                smoothness = math.clamp(smoothness, 0.01, 1)
                local lookVector = (target - Cam.CFrame.Position).unit
                local targetCFrame = CFrame.new(Cam.CFrame.Position, Cam.CFrame.Position + lookVector)
                Cam.CFrame = Cam.CFrame:Lerp(targetCFrame, smoothness)
            end
            
            local function getClosestPlayerInFOV(targetPart)
                local nearest = nil
                local closestDistance = math.huge
                local centerScreen = Cam.ViewportSize / 2
                
                for _, player in ipairs(Players:GetPlayers()) do
                    if player ~= LocalPlayer then
                        if State.Features.Aimbot.FriendCheck and table.find(State.Friends, player.Name) then
                            continue
                        end
                        
                        local character = player.Character
                        if not character then continue end
                        
                        local humanoid = character:FindFirstChildOfClass("Humanoid")
                        if not humanoid or humanoid.Health <= 0 then continue end
                        
                        local part = character:FindFirstChild(targetPart)
                        if not part then continue end
                        
                        local screenPos, onScreen = Cam:WorldToViewportPoint(part.Position)
                        if not onScreen then continue end
                        
                        local screenPos2D = Vector2.new(screenPos.X, screenPos.Y)
                        local distanceFromCenter = (screenPos2D - centerScreen).Magnitude
                        
                        if distanceFromCenter > State.Features.Aimbot.FOVRadius then continue end
                        
                        if State.Features.Aimbot.WallCheck then
                            local ray = Ray.new(Cam.CFrame.Position, (part.Position - Cam.CFrame.Position).Unit * 500)
                            local hitPart = workspace:FindPartOnRayWithIgnoreList(ray, {LocalPlayer.Character, character})
                            if hitPart then continue end
                        end
                        
                        if distanceFromCenter < closestDistance then
                            closestDistance = distanceFromCenter
                            nearest = part
                        end
                    end
                end
                
                return nearest
            end
            
            local aimbotConnection = RunService.RenderStepped:Connect(function()
                if not State.Features.Aimbot.Enabled then
                    FOVring.Visible = false
                    return
                end
                
                FOVring.Visible = State.Features.Aimbot.ShowFOV
                
                if State.Features.Aimbot.ShowFOV then
                    updateFOV()
                end
                
                local targetPart = getClosestPlayerInFOV("Head")
                if targetPart then
                    smoothLookAt(targetPart.Position, State.Features.Aimbot.Smoothness)
                end
            end)
            
            State.Features.Aimbot.mobileConnection = aimbotConnection
            State.Features.Aimbot.mobileFOVring = FOVring
            State.Features.Aimbot.Loaded = true
            
        else
            -- PC: Usar Exunys Aimbot
            -- Apenas configurar - NÃO chamar Load() ainda
            ExunysDeveloperAimbot.Settings.Enabled = false
            ExunysDeveloperAimbot.Settings.TriggerKey = Enum.UserInputType.MouseButton2
            ExunysDeveloperAimbot.Settings.Toggle = false
            ExunysDeveloperAimbot.Settings.LockMode = 1
            ExunysDeveloperAimbot.Settings.LockPart = "Head"
            ExunysDeveloperAimbot.Settings.TeamCheck = false
            ExunysDeveloperAimbot.Settings.AliveCheck = true
            ExunysDeveloperAimbot.Settings.WallCheck = State.Features.Aimbot.WallCheck
            ExunysDeveloperAimbot.Settings.Sensitivity = State.Features.Aimbot.Smoothness
            ExunysDeveloperAimbot.Settings.Sensitivity2 = 3.5
            ExunysDeveloperAimbot.Settings.OffsetToMoveDirection = false
            ExunysDeveloperAimbot.Settings.OffsetIncrement = 15
            
            ExunysDeveloperAimbot.FOVSettings.Enabled = true
            ExunysDeveloperAimbot.FOVSettings.Visible = State.Features.Aimbot.ShowFOV
            ExunysDeveloperAimbot.FOVSettings.Radius = State.Features.Aimbot.FOVRadius
            ExunysDeveloperAimbot.FOVSettings.NumSides = 60
            ExunysDeveloperAimbot.FOVSettings.Thickness = 2
            ExunysDeveloperAimbot.FOVSettings.Transparency = 1
            ExunysDeveloperAimbot.FOVSettings.Filled = false
            ExunysDeveloperAimbot.FOVSettings.RainbowColor = false
            ExunysDeveloperAimbot.FOVSettings.RainbowOutlineColor = false
            ExunysDeveloperAimbot.FOVSettings.Color = State.Features.Aimbot.FOVColor
            ExunysDeveloperAimbot.FOVSettings.OutlineColor = Color3.fromRGB(0, 0, 0)
            ExunysDeveloperAimbot.FOVSettings.LockedColor = State.Features.Aimbot.FOVColor
            
            ExunysDeveloperAimbot.Blacklisted = State.Friends
            
            -- AGORA SIM: Carregar o Aimbot (inicia os loops internos)
            ExunysDeveloperAimbot() -- Ou ExunysDeveloperAimbot:Load() ou ExunysDeveloperAimbot.Load()
            
            State.Features.Aimbot.Loaded = true
        end
    end)
    
    if not success then
        warn("[DN Menu] Erro ao carregar Aimbot:", err)
        return false, err
    end
    
    return true, "Aimbot carregado com sucesso"
end

function CombatModule.UpdateAimbotSettings()
    if not State.Features.Aimbot.Loaded then return end
   
    if Utils.IsMobile() then
        if State.Features.Aimbot.mobileFOVring then
            State.Features.Aimbot.mobileFOVring.Visible = State.Features.Aimbot.ShowFOV
        end
    else
        pcall(function()
            ExunysDeveloperAimbot.Settings.Enabled = State.Features.Aimbot.Enabled
            ExunysDeveloperAimbot.Settings.WallCheck = State.Features.Aimbot.WallCheck
            ExunysDeveloperAimbot.Settings.Sensitivity = State.Features.Aimbot.Smoothness
            
            ExunysDeveloperAimbot.FOVSettings.Visible = State.Features.Aimbot.ShowFOV
            ExunysDeveloperAimbot.FOVSettings.Radius = State.Features.Aimbot.FOVRadius
            ExunysDeveloperAimbot.FOVSettings.Color = State.Features.Aimbot.FOVColor
            
            ExunysDeveloperAimbot.Blacklisted = State.Friends
        end)
    end
end


function CombatModule.ActivateHeadHitboxExpander(enabled)
    local feature = State.Features.HeadHitboxExpander
    feature.active = enabled
    
    if enabled then
        -- Ativar: criar hitboxes invisíveis maiores
        for _, player in ipairs(Services.Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local head = player.Character:FindFirstChild("Head")
                if head and head:IsA("BasePart") then
                    -- Salvar tamanho original
                    if not feature.originalSizes[player.UserId] then
                        feature.originalSizes[player.UserId] = head.Size
                    end
                    
                    -- IMPORTANTE: Não alterar a propriedade Size visualmente
                    -- Criar hitbox invisível maior
                    local hitbox = head:FindFirstChild("DNMenu_Hitbox")
                    if not hitbox then
                        hitbox = Instance.new("Part")
                        hitbox.Name = "DNMenu_Hitbox"
                        hitbox.Size = Vector3.new(feature.size, feature.size, feature.size)
                        hitbox.Transparency = 1
                        hitbox.CanCollide = false
                        hitbox.Massless = true
                        hitbox.CFrame = head.CFrame
                        
                        local weld = Instance.new("WeldConstraint")
                        weld.Part0 = head
                        weld.Part1 = hitbox
                        weld.Parent = hitbox
                        
                        hitbox.Parent = head
                    else
                        hitbox.Size = Vector3.new(feature.size, feature.size, feature.size)
                    end
                end
            end
        end
        
        -- Hook para novos jogadores
        if not feature.playerAddedConnection then
            feature.playerAddedConnection = Services.Players.PlayerAdded:Connect(function(player)
                if feature.active then
                    player.CharacterAdded:Connect(function(char)
                        task.wait(0.5)
                        local head = char:FindFirstChild("Head")
                        if head and head:IsA("BasePart") and feature.active then
                            if not feature.originalSizes[player.UserId] then
                                feature.originalSizes[player.UserId] = head.Size
                            end
                            
                            local hitbox = head:FindFirstChild("DNMenu_Hitbox")
                            if not hitbox then
                                hitbox = Instance.new("Part")
                                hitbox.Name = "DNMenu_Hitbox"
                                hitbox.Size = Vector3.new(feature.size, feature.size, feature.size)
                                hitbox.Transparency = 1
                                hitbox.CanCollide = false
                                hitbox.Massless = true
                                hitbox.CFrame = head.CFrame
                                
                                local weld = Instance.new("WeldConstraint")
                                weld.Part0 = head
                                weld.Part1 = hitbox
                                weld.Parent = hitbox
                                
                                hitbox.Parent = head
                            end
                        end
                    end)
                end
            end)
        end
    else
        -- Desativar: remover hitboxes invisíveis
        for _, player in ipairs(Services.Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local head = player.Character:FindFirstChild("Head")
                if head then
                    local hitbox = head:FindFirstChild("DNMenu_Hitbox")
                    if hitbox then
                        hitbox:Destroy()
                    end
                end
            end
        end
        
        if feature.playerAddedConnection then
            feature.playerAddedConnection:Disconnect()
            feature.playerAddedConnection = nil
        end
        
        feature.originalSizes = {}
    end
end

function CombatModule.SetHeadHitboxSize(size)
    State.Features.HeadHitboxExpander.size = size
    if State.Features.HeadHitboxExpander.active then
        -- Atualizar apenas as hitboxes invisíveis
        for _, player in ipairs(Services.Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local head = player.Character:FindFirstChild("Head")
                if head then
                    local hitbox = head:FindFirstChild("DNMenu_Hitbox")
                    if hitbox then
                        hitbox.Size = Vector3.new(size, size, size)
                    end
                end
            end
        end
    end
end

function CombatModule.SetHeadHitboxTransparency(trans)
    -- Esta função agora é apenas para compatibilidade
    -- A hitbox sempre será invisível (transparency = 1)
    State.Features.HeadHitboxExpander.transparency = 1
end

function CombatModule.SetHeadHitboxSize(size)
    State.Features.HeadHitboxExpander.size = size
    if State.Features.HeadHitboxExpander.active then
        for _, player in ipairs(Services.Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local head = player.Character:FindFirstChild("Head")
                if head then
                    head.Size = Vector3.new(size, size, size)
                end
            end
        end
    end
end

function CombatModule.SetHeadHitboxTransparency(trans)
    State.Features.HeadHitboxExpander.transparency = trans
    if State.Features.HeadHitboxExpander.active then
        for _, player in ipairs(Services.Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local head = player.Character:FindFirstChild("Head")
                if head then
                    head.Transparency = trans
                end
            end
        end
    end
end

-- ==========================================
-- MÓDULO LISTA DE JOGADORES
-- ==========================================
local PlayerListModule = {}
function PlayerListModule.UpdatePlayerList()
    State.Players.list = {}
    for _, player in ipairs(Services.Players:GetPlayers()) do
        table.insert(State.Players.list, player.Name)
    end
    return State.Players.list
end
function PlayerListModule.SelectPlayer(playerName)
    State.Players.selected = Services.Players:FindFirstChild(playerName)
    State.Features.BangPlayer.target = State.Players.selected
end
function PlayerListModule.TeleportToPlayer()
    if not State.Players.selected or not State.Players.selected.Character then
        return
    end
    local hrp = Utils.GetRootPart()
    local targetHRP = Utils.GetRootPart(State.Players.selected)
    if hrp and targetHRP then
        hrp.CFrame = targetHRP.CFrame
    end
end
-- ==========================================
-- MÓDULO DE AUTENTICAÇÃO
-- ==========================================
local AuthModule = {}
function AuthModule.CheckAuth()
    local success, response = pcall(function()
        return game:HttpGet(Config.AllowedUsersURL)
    end)
    if not success then
        return false
    end
    local allowed = {}
    for line in response:gmatch("[^\r\n]+") do
        local trimmed = line:match("^%s*(.-)%s*$")
        if trimmed ~= "" and not trimmed:match("^#") then
            allowed[trimmed] = true
        end
    end
    return allowed[LocalPlayer.Name] or false
end
function AuthModule.StartAuthVerification()
    if State.Auth.verificationConnection then return end
    State.Auth.verificationConnection = task.spawn(function()
        while true do
            task.wait(State.Auth.checkInterval)
            local currentTime = tick()
            if currentTime - State.Auth.lastCheck < State.Auth.checkInterval then
                continue
            end
            State.Auth.lastCheck = currentTime
            if not AuthModule.CheckAuth() then
                LocalPlayer:Kick("Sua sessão expirou 😿. Adquira uma nova licença para o DN Menu e volte a ter a melhor experiência novamente conosco!")
            end
        end
    end)
end
function AuthModule.StopAuthVerification()
    if State.Auth.verificationConnection then
        task.cancel(State.Auth.verificationConnection)
        State.Auth.verificationConnection = nil
    end
end
-- ==========================================
-- MÓDULO ESP ADMINS NOVO
-- ==========================================
-- ==========================================
-- MÓDULO WEAPON EDITOR
-- ==========================================
local WeaponModule = {}
local requireCache = {}
function WeaponModule.safeRequire(module)
    if requireCache[module] then
        return requireCache[module]
    end
    local success, result = pcall(require, module)
    if not success then
        warn("⚠️ Erro ao carregar módulo: " .. tostring(module))
        warn(" Motivo: " .. tostring(result))
        return {
            Type = "Gun",
            Ammo = 30,
            ShootRate = 850,
            Bullets = 1,
        }
    end
    if type(result) == "table" and not result.Type then
        warn("⚠️ Módulo sem 'Type', adicionando Type='Gun'")
        result.Type = "Gun"
    end
    requireCache[module] = result
    return result
end
function WeaponModule.patchWeapon(weapon)
    if not weapon:IsA("Tool") then return end
    local settingsModule = weapon:FindFirstChild("ACS_Settings")
    if not settingsModule then return end
    local success, settings = pcall(WeaponModule.safeRequire, settingsModule)
    if success and settings then
        if not settings.Type then
            settings.Type = "Gun"
            print("🔧 Adicionado Type='Gun' em " .. weapon.Name)
        end
        local defaults = {
            Ammo = 30,
            ShootRate = 850,
            Bullets = 1,
            BulletPenetration = 100,
            HeadDamage = {100, 100},
            TorsoDamage = {50, 55},
            LimbDamage = {30, 35},
            camRecoil = {
                camRecoilUp = {10, 12},
                camRecoilTilt = {25, 40},
                camRecoilLeft = {16, 25},
                camRecoilRight = {13, 19}
            },
            gunRecoil = {
                gunRecoilUp = {60, 75},
                gunRecoilTilt = {15, 25},
                gunRecoilLeft = {15, 25},
                gunRecoilRight = {15, 25}
            }
        }
        for key, value in pairs(defaults) do
            if settings[key] == nil then
                settings[key] = value
            end
        end
        print("✓ " .. weapon.Name .. " validado e corrigido")
    end
end
function WeaponModule.forceFix(weaponName)
    local player = game.Players.LocalPlayer
    local backpack = player.Backpack
    local character = player.Character
    local weapon = character:FindFirstChild(weaponName) or backpack:FindFirstChild(weaponName)
    if not weapon then
        warn("❌ Arma não encontrada")
        return
    end
    local wasEquipped = (weapon.Parent == character)
    if wasEquipped then
        weapon.Parent = backpack
        task.wait(0.1)
    end
    WeaponModule.patchWeapon(weapon)
    task.wait(0.2)
    if wasEquipped then
        weapon.Parent = character
    end
end
-- Funções de edição específicas
function WeaponModule.SetFireRate(weapon, value)
    local settingsModule = weapon:FindFirstChild("ACS_Settings")
    if settingsModule then
        local settings = WeaponModule.safeRequire(settingsModule)
        settings.ShootRate = value
    end
end
function WeaponModule.SetAmmo(weapon, value)
    local settingsModule = weapon:FindFirstChild("ACS_Settings")
    if settingsModule then
        local settings = WeaponModule.safeRequire(settingsModule)
        settings.Ammo = value
        settings.AmmoInGun = value
        settings.StoredAmmo = value * 20
        settings.MaxStoredAmmo = value * 20
    end
end
function WeaponModule.SetBullets(weapon, value)
    local settingsModule = weapon:FindFirstChild("ACS_Settings")
    if settingsModule then
        local settings = WeaponModule.safeRequire(settingsModule)
        settings.Bullets = value
    end
end
function WeaponModule.SetPenetration(weapon, value)
    local settingsModule = weapon:FindFirstChild("ACS_Settings")
    if settingsModule then
        local settings = WeaponModule.safeRequire(settingsModule)
        settings.BulletPenetration = value
    end
end
function WeaponModule.SetHeadDamage(weapon, value)
    local settingsModule = weapon:FindFirstChild("ACS_Settings")
    if settingsModule then
        local settings = WeaponModule.safeRequire(settingsModule)
        settings.HeadDamage = {value, value}
    end
end
function WeaponModule.SetTorsoDamage(weapon, value)
    local settingsModule = weapon:FindFirstChild("ACS_Settings")
    if settingsModule then
        local settings = WeaponModule.safeRequire(settingsModule)
        settings.TorsoDamage = {value, value + 5}
        settings.LimbDamage = {math.floor(value / 2.5), math.floor(value / 2.5) + 5}
    end
end
function WeaponModule.SetNoRecoil(weapon, enabled)
    local settingsModule = weapon:FindFirstChild("ACS_Settings")
    if settingsModule then
        local settings = WeaponModule.safeRequire(settingsModule)
        if enabled then
            settings.camRecoil = {
                camRecoilUp = {0, 0},
                camRecoilTilt = {0, 0},
                camRecoilLeft = {0, 0},
                camRecoilRight = {0, 0}
            }
            settings.gunRecoil = {
                gunRecoilUp = {0, 0},
                gunRecoilTilt = {0, 0},
                gunRecoilLeft = {0, 0},
                gunRecoilRight = {0, 0}
            }
            settings.MinRecoilPower = 0
            settings.MaxRecoilPower = 0
        else
            settings.camRecoil = {
                camRecoilUp = {10, 12},
                camRecoilTilt = {25, 40},
                camRecoilLeft = {16, 25},
                camRecoilRight = {13, 19}
            }
            settings.gunRecoil = {
                gunRecoilUp = {60, 75},
                gunRecoilTilt = {15, 25},
                gunRecoilLeft = {15, 25},
                gunRecoilRight = {15, 25}
            }
            settings.MinRecoilPower = 0.4
            settings.MaxRecoilPower = 1.4
        end
    end
end
function WeaponModule.SetExplosiveBullets(weapon, enabled)
    local settingsModule = weapon:FindFirstChild("ACS_Settings")
    if settingsModule then
        local settings = WeaponModule.safeRequire(settingsModule)
        settings.ExplosiveAmmo = enabled
    end
end
function WeaponModule.SetRainbowBullets(weapon, enabled)
    local settingsModule = weapon:FindFirstChild("ACS_Settings")
    if settingsModule then
        local settings = WeaponModule.safeRequire(settingsModule)
        settings.RainbowMode = enabled
    end
end
function WeaponModule.SetFireMode(weapon, mode)
    local settingsModule = weapon:FindFirstChild("ACS_Settings")
    if settingsModule then
        local settings = WeaponModule.safeRequire(settingsModule)
        settings.ShootType = (mode == "Semi") and 1 or 3
    end
end
function WeaponModule.SetHelmetProtection(value)
    local acsClient = LocalPlayer.Character:FindFirstChild("ACS_Client") or LocalPlayer.Character:FindFirstChild("AntiCheat") or LocalPlayer.Character:FindFirstChildWhichIsA("Folder") -- Ajustar se necessário
    if acsClient and acsClient:FindFirstChild("Protecao") then
        acsClient.Protecao.HelmetProtect.Value = value
        acsClient.Protecao.HelmetBlastProtect.Value = value
    end
end
function WeaponModule.SetVestProtection(value)
    local acsClient = LocalPlayer.Character:FindFirstChild("ACS_Client") or LocalPlayer.Character:FindFirstChild("AntiCheat") or LocalPlayer.Character:FindFirstChildWhichIsA("Folder")
    if acsClient and acsClient:FindFirstChild("Protecao") then
        acsClient.Protecao.VestProtect.Value = value
        acsClient.Protecao.VestBlastProtect.Value = value
    end
end
function WeaponModule.SetNoCameraShake(enabled)
    local acsClient = LocalPlayer.Character:FindFirstChild("ACS_Client") or LocalPlayer.Character:FindFirstChild("AntiCheat") or LocalPlayer.Character:FindFirstChildWhichIsA("Folder")
    if acsClient and acsClient:FindFirstChild("Variaveis") then
        local stamina = acsClient.Variaveis:FindFirstChild("Stamina")
        if stamina then
            stamina.Value = enabled and math.huge or 100 -- Assumindo default 100
        end
    end
end

function WeaponModule.SetTracer(weapon, enabled)
    if not weapon or not weapon:FindFirstChild("ACS_Settings") then return end
    local settings = WeaponModule.safeRequire(weapon.ACS_Settings)
    if settings then
        settings.Tracer = enabled
    end
end

function WeaponModule.SetTracerColor(weapon, color)
    if not weapon or not weapon:FindFirstChild("ACS_Settings") then return end
    local settings = WeaponModule.safeRequire(weapon.ACS_Settings)
    if settings then
        settings.TracerColor = color
    end
end

function WeaponModule.SetExplosionRadius(weapon, radius)
    if not weapon or not weapon:FindFirstChild("ACS_Settings") then return end
    local settings = WeaponModule.safeRequire(weapon.ACS_Settings)
    if settings then
        settings.ExplosionRadius = radius
    end
end

function WeaponModule.SetBulletDrop(weapon, value)
    if not weapon or not weapon:FindFirstChild("ACS_Settings") then return end
    local settings = WeaponModule.safeRequire(weapon.ACS_Settings)
    if settings then
        settings.BulletDrop = value
    end
end

function WeaponModule.GetWeaponsList()
    local weapons = {}
    for _, item in ipairs(LocalPlayer.Backpack:GetChildren()) do
        if item:IsA("Tool") and item:FindFirstChild("ACS_Settings") then
            table.insert(weapons, item.Name)
        end
    end
    for _, item in ipairs(LocalPlayer.Character:GetChildren()) do
        if item:IsA("Tool") and item:FindFirstChild("ACS_Settings") then
            table.insert(weapons, item.Name)
        end
    end
    return weapons
end
-- ==========================================
-- CLEANUP COMPLETO
-- ==========================================
local function PerformCleanup()
    if State.Features.Exorcismo.active then
        ExploitModule.ActivateExorcismo(false)
        task.wait(0.3)
    end
if State.Features.ESP.loaded then
    pcall(function()
        ExunysDeveloperESP:Exit()
    end)
    State.Features.ESP.loaded = false
end

if State.Features.Aimbot.Loaded then
    if Utils.IsMobile() then
        if State.Features.Aimbot.mobileConnection then
            State.Features.Aimbot.mobileConnection:Disconnect()
            State.Features.Aimbot.mobileConnection = nil
        end
        if State.Features.Aimbot.mobileFOVring then
            State.Features.Aimbot.mobileFOVring:Remove()
            State.Features.Aimbot.mobileFOVring = nil
        end
    else
        pcall(function()
            ExunysDeveloperAimbot:Exit()
        end)
    end
    State.Features.Aimbot.Loaded = false
end
    VisualModule.ActivateChams(false)
    VisualModule.ActivateFullbright(false)
    ExploitModule.ActivateGunPull(false)
    ExploitModule.ActivateBangPlayer(false)
    ExploitModule.ActivateVehicleLauncher(false)
    ExploitModule.ActivateAutoUnlock(false)
    ExploitModule.ActivateVehicleDelete(false)
    ExploitModule.ActivateVehicleFly(false)
    ExploitModule.ActivateVehicleNoclip(false)
    CombatModule.ActivateHitboxExpander(false)
    CombatModule.ActivateHeadHitboxExpander(false)
    PlayerModule.ActivateNoclip(false)
    PlayerModule.ActivateSpeed(false)
    PlayerModule.ActivateJumpPower(false)
    for _, feature in pairs(State.Features) do
        if feature.connection then
            Utils.ClearConnections({feature.connection})
        end
        if feature.connections then
            Utils.ClearConnections(feature.connections)
        end
    end
    PortaMalasModule.StopMonitoring()
    if getgenv().DNMenuAimbot then
        State.Features.Aimbot.Enabled = false
        CombatModule.UpdateAimbotSettings()
        if getgenv().DNMenuAimbot.FOVBox then
            getgenv().DNMenuAimbot.FOVBox:Remove()
        end
        if getgenv().DNMenuAimbot.SilentFOVBox then
            getgenv().DNMenuAimbot.SilentFOVBox:Remove()
        end
        getgenv().DNMenuAimbot = nil
    end
    PortaMalasModule.ClearClonedTrunk()
    if State.Features.Chams.folder then
        State.Features.Chams.folder:Destroy()
    end
    for _, billboard in pairs(State.Features.ESP.billboards) do
        if billboard then billboard:Destroy() end
    end
    State.Features.ESP.billboards = {}
    if State.Features.Fullbright.active then
        VisualModule.ActivateFullbright(false)
    end
    -- Adições para restaurar tudo
    PlayerModule.SetCameraFOV(Config.Defaults.CameraFOV)
    State.Features.Speed.value = Config.Defaults.Speed
    State.Vehicles.unlockRange = Config.Defaults.VehicleRange
    State.Features.ESP.color = Color3.fromRGB(138, 43, 226)
    State.Features.ESPSkeleton.color = Color3.fromRGB(138, 43, 226)
    State.Features.ESPAdmin.adminColor = Color3.fromRGB(255, 0, 0)
    State.Features.Chams.fillColor = Color3.fromRGB(138, 43, 226)
    State.Features.Chams.outlineColor = Color3.fromRGB(75, 0, 130)
    State.Features.Aimbot.FOVColor = Color3.fromRGB(138, 43, 226)
    State.Features.Aimbot.SilentFOVColor = Color3.fromRGB(255, 0, 0)
end
local function SetupAutoCleanup(Window)
    LocalPlayer.AncestryChanged:Connect(function()
        PerformCleanup()
        AuthModule.StopAuthVerification()
    end)
end
local function BypassTelagem(WindUI)
    PerformCleanup()
    for _, feature in pairs(State.Features) do
        if feature.toggle and feature.toggle.Set then
            pcall(function()
                feature.toggle:Set(false)
            end)
        end
    end
    WindUI:Notify({
        Title = "Bypass Telagem",
        Content = "Todas as funcionalidades foram desativadas",
        Icon = "power",
        Duration = 3
    })
end
local function SetupToggleVisibility(Window)
    Services.UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.KeyCode == Enum.KeyCode.F3 then
            Window:Toggle()
        end
    end)
    if Utils.IsMobile() then
        local lastTapTime = 0
        local tapCount = 0
        Services.UserInputService.TouchStarted:Connect(function(touch, gameProcessed)
            if gameProcessed then return end
            local touches = Services.UserInputService:GetTouches()
            if #touches >= 3 then
                local currentTime = tick()
                if currentTime - lastTapTime < 0.5 then
                    tapCount = tapCount + 1
                    if tapCount >= 2 then
                        Window:Toggle()
                        tapCount = 0
                    end
                else
                    tapCount = 1
                end
                lastTapTime = currentTime
            end
        end)
    end
end
-- ==========================================
-- INTERFACE - ADICIONAR ELEMENTOS
-- ==========================================
local function AddMenuElements(Window, WindUI)
    local PlayerTab = Window:Tab({
        Title = "Jogador",
        Icon = "user",
        IconColor = Color3.fromRGB(138, 43, 226),
    })
    local PlayerSection = PlayerTab:Section({
        Title = "Local Player",
    })
    local PlayerColorsSection = PlayerTab:Section({
        Title = "Cores",
    })
    State.Features.Speed.toggle = PlayerSection:Toggle({
        Title = "Speed Hack",
        Desc = "Aumenta a velocidade de movimento",
Icon = "check",
Type = "Checkbox",
IconSize = 8*2,
        Callback = function(value)
            PlayerModule.ActivateSpeed(value)
        end
    })
    PlayerSection:Slider({
        Title = "Velocidade",
        Desc = "Ajuste a velocidade (padrão: 16)",
        Step = 1,
        Value = {
            Min = 16,
            Max = 200,
            Default = Config.Defaults.Speed,
        },
        Callback = function(value)
            PlayerModule.SetSpeed(value)
        end
    })
    State.Features.JumpPower.toggle = PlayerSection:Toggle({
        Title = "Jump Power",
        Desc = "Aumenta a força do pulo",
Icon = "check",
Type = "Checkbox",
IconSize = 8*2,
        Callback = function(value)
            PlayerModule.ActivateJumpPower(value)
        end
    })
    PlayerSection:Slider({
        Title = "Força do Pulo",
        Desc = "Ajuste a força do pulo (padrão: 50)",
        Step = 1,
        Value = {
            Min = 50,
            Max = 300,
            Default = Config.Defaults.JumpPower,
        },
        Callback = function(value)
            PlayerModule.SetJumpPower(value)
        end
    })
    PlayerSection:Slider({
        Title = "Camera FOV",
        Desc = "Ajuste o campo de visão da câmera (padrão: 70)",
        Step = 1,
        Value = {
            Min = 1,
            Max = 100,
            Default = Config.Defaults.CameraFOV,
        },
        Callback = function(value)
            PlayerModule.SetCameraFOV(value)
        end
    })
    State.Features.Godmode.toggle = PlayerSection:Toggle({
        Title = "Invulnerabilidade",
        Desc = "Seu personagem não perde vida",
        Locked = true,
Icon = "check",
Type = "Checkbox",
IconSize = 8*2,
        Callback = function(value)
            PlayerModule.ActivateGodmode(value)
        end
    })
    State.Features.Noclip.toggle = PlayerSection:Toggle({
        Title = "Atravessar Paredes (Noclip)",
        Desc = "Permite atravessar paredes",
Icon = "check",
Type = "Checkbox",
IconSize = 8*2,
        Callback = function(value)
            PlayerModule.ActivateNoclip(value)
        end
    })
    State.Features.SoloSession.toggle = PlayerSection:Toggle({
        Title = "Invisible Solo Session",
        Desc = "Fica invisível e deslocado",
        Locked = true,
Icon = "check",
Type = "Checkbox",
IconSize = 8*2,
        Callback = function(value)
            PlayerModule.ActivateSoloSession(value)
        end
    })
local VisualTab = Window:Tab({
    Title = "Visuais",
    Icon = "eye",
    IconColor = Color3.fromRGB(138, 43, 226),
})

local EspSection = VisualTab:Section({
    Title = "ESP",
})

local VisualColorsSection = VisualTab:Section({
    Title = "Cores",
})

-- Botão Carregar ESP
EspSection:Button({
    Title = "Carregar ESP",
    Desc = "Carrega o sistema Exunys ESP",
    Callback = function()
        local success, message = VisualModule.LoadESP()
        WindUI:Notify({
            Title = success and "Sucesso" or "Erro",
            Content = message or "ESP carregado",
            Icon = success and "check" or "x"
        })
    end
})

-- Toggle ESP Jogadores
State.Features.ESP.toggle = EspSection:Toggle({
    Title = "ESP Jogadores",
    Desc = "Mostra informações através de paredes",
    Icon = "check",
    Type = "Checkbox",
    IconSize = 16,
    Callback = function(value)
        VisualModule.ActivateESP(value)
    end
})

-- Toggle ESP Veículos
State.Features.CarESP.toggle = EspSection:Toggle({
    Title = "ESP Veículos",
    Desc = "Detecta pelo Chassis",
    Icon = "check",
    Type = "Checkbox",
    IconSize = 16,
    Callback = function(value)
        VisualModule.ActivateCarESP(value)
    end
})

-- Toggle Chams
State.Features.Chams.toggle = EspSection:Toggle({
    Title = "Chams",
    Desc = "Destaca jogadores com contorno 3D",
    Icon = "check",
    Type = "Checkbox",
    IconSize = 16,
    Callback = function(value)
        VisualModule.ActivateChams(value)
    end
})

-- Toggle Fullbright
State.Features.Fullbright.toggle = EspSection:Toggle({
    Title = "Fullbright",
    Desc = "Iluminação máxima no mapa",
    Icon = "check",
    Type = "Checkbox",
    IconSize = 16,
    Callback = function(value)
        VisualModule.ActivateFullbright(value)
    end
})

-- Toggle Self ESP
State.Features.ESP.selfESPToggle = EspSection:Toggle({
    Title = "Self ESP",
    Desc = "Mostra ESP no próprio jogador",
    Default = false,
    Icon = "check",
    Type = "Checkbox",
    IconSize = 16,
    Callback = function(value)
        VisualModule.UpdateSelfESP(value)
    end
})

-- Toggle Visible Check
State.Features.ESP.visibleCheckToggle = EspSection:Toggle({
    Title = "Visible Check",
    Desc = "Cores diferentes para jogadores atrás de paredes",
    Default = true,
    Icon = "check",
    Type = "Checkbox",
    IconSize = 16,
    Callback = function(value)
        VisualModule.UpdateVisibleCheck(value)
    end
})

-- Toggle Tracers
EspSection:Toggle({
    Title = "Tracers (Linhas)",
    Desc = "Linhas conectando você aos jogadores",
    Default = false,
    Icon = "check",
    Type = "Checkbox",
    IconSize = 16,
    Callback = function(value)
        VisualModule.ToggleTracers(value)
    end
})

-- Colorpicker Cor do ESP
VisualColorsSection:Colorpicker({
    Title = "Cor do ESP",
    Desc = "Cor do texto/nome/distância",
    Default = State.Features.ESP.color,
    Callback = function(value)
        VisualModule.UpdateESPColor(value)
    end
})

-- Colorpicker Cor Box Visível
VisualColorsSection:Colorpicker({
    Title = "Cor da Box (Visível)",
    Desc = "Cor da box quando o jogador está visível",
    Default = State.Features.ESP.boxColor,
    Callback = function(value)
        VisualModule.UpdateBoxColor(value)
    end
})

-- Colorpicker Cor Box Invisível
VisualColorsSection:Colorpicker({
    Title = "Cor da Box (Invisível)",
    Desc = "Cor da box quando o jogador está atrás da parede",
    Default = State.Features.ESP.invisibleBoxColor,
    Callback = function(value)
        VisualModule.UpdateInvisibleBoxColor(value)
    end
})

-- Colorpicker Cor Chams
VisualColorsSection:Colorpicker({
    Title = "Cor dos Chams",
    Desc = "Cor do preenchimento 3D",
    Default = State.Features.Chams.fillColor,
    Callback = function(value)
        State.Features.Chams.fillColor = value
        VisualModule.UpdateChamsColors()
    end
})

-- AGORA CONTINUA COM ExploitTab
local ExploitTab = Window:Tab({
    Title = "Exploits",
    Icon = "zap",
    IconColor = Color3.fromRGB(138, 43, 226),
})
    local PlayerSpecificSection = ExploitTab:Section({
        Title = "Ações de Jogador",
    })
    local playerList = PlayerListModule.UpdatePlayerList()
    local PlayerDropdownExploit = PlayerSpecificSection:Dropdown({
        Title = "Selecionar Jogador",
        Desc = "Escolha um jogador",
        Values = playerList,
        Value = playerList[1] or "Nenhum",
        Callback = function(value)
            PlayerListModule.SelectPlayer(value)
        end
    })
    PlayerSpecificSection:Button({
        Title = "Atualizar Lista",
        Desc = "Recarrega a lista de jogadores",
        Callback = function()
            local updatedList = PlayerListModule.UpdatePlayerList()
            PlayerDropdownExploit:Refresh(updatedList)
            WindUI:Notify({
                Title = "Lista Atualizada",
                Content = #updatedList .. " jogador(es) encontrado(s)",
                Icon = "refresh-cw"
            })
        end
    })
    PlayerSpecificSection:Button({
        Title = "Adicionar Amigo",
        Desc = "Adiciona o jogador selecionado como amigo (ignora aimbot)",
        Callback = function()
            if State.Players.selected then
                ExploitModule.AddFriend(State.Players.selected.Name)
                WindUI:Notify({
                    Title = "Amigo Adicionado",
                    Content = State.Players.selected.Name .. " adicionado aos amigos",
                    Icon = "user-plus"
                })
            end
        end
    })
    PlayerSpecificSection:Button({
        Title = "Remover Amigo",
        Desc = "Remove o jogador selecionado dos amigos",
        Callback = function()
            if State.Players.selected then
                ExploitModule.RemoveFriend(State.Players.selected.Name)
                WindUI:Notify({
                    Title = "Amigo Removido",
                    Content = State.Players.selected.Name .. " removido dos amigos",
                    Icon = "user-minus"
                })
            end
        end
    })
    State.Features.BangPlayer.toggle = PlayerSpecificSection:Toggle({
        Title = "Grudar no Jogador",
        Desc = "Gruda atrás do jogador selecionado",
Icon = "check",
Type = "Checkbox",
IconSize = 8*2,
        Callback = function(value)
            if value and not State.Players.selected then
                WindUI:Notify({
                    Title = "Erro",
                    Content = "Selecione um jogador primeiro",
                    Icon = "x"
                })
                State.Features.BangPlayer.toggle:Set(false)
                return
            end
            ExploitModule.ActivateBangPlayer(value)
        end
    })
    PlayerSpecificSection:Button({
        Title = "Teleportar para Jogador",
        Desc = "Teleporta até o jogador selecionado",
        Callback = function()
            if not State.Players.selected then
                WindUI:Notify({
                    Title = "Erro",
                    Content = "Selecione um jogador primeiro",
                    Icon = "x"
                })
                return
            end
            PlayerListModule.TeleportToPlayer()
            WindUI:Notify({
                Title = "Teleporte",
                Content = "Teleportado para " .. State.Players.selected.Name,
                Icon = "zap"
            })
        end
    })
    PlayerSpecificSection:Button({
        Title = "Spectate Jogador",
        Desc = "Observa o jogador selecionado",
        Callback = function()
            if State.Players.selected and State.Players.selected.Character then
                Services.Workspace.CurrentCamera.CameraSubject = State.Players.selected.Character
                WindUI:Notify({
                    Title = "Spectate",
                    Content = "Observando " .. State.Players.selected.Name,
                    Icon = "eye"
                })
            else
                WindUI:Notify({
                    Title = "Erro",
                    Content = "Jogador inválido",
                    Icon = "x"
                })
            end
        end
    })
    PlayerSpecificSection:Button({
        Title = "Parar Spectate",
        Desc = "Retorna a câmera",
        Callback = function()
            Services.Workspace.CurrentCamera.CameraSubject = Utils.GetHumanoid()
            WindUI:Notify({
                Title = "Spectate",
                Content = "Câmera restaurada",
                Icon = "eye-off"
            })
        end
    })
    local GeneralExploitsSection = ExploitTab:Section({
        Title = "Exploits Gerais",
    })
    State.Features.GunPull.toggle = GeneralExploitsSection:Toggle({
        Title = "Puxar Armas",
        Desc = "Puxa armas de outros jogadores",
Icon = "check",
Type = "Checkbox",
IconSize = 8*2,
        Callback = function(value)
            ExploitModule.ActivateGunPull(value)
        end
    })
    State.Features.Exorcismo.toggle = GeneralExploitsSection:Toggle({
        Title = "Exorcismo",
        Desc = "Ativa animações customizadas",
Icon = "check",
Type = "Checkbox",
IconSize = 8*2,
        Callback = function(value)
            ExploitModule.ActivateExorcismo(value)
        end
    })
GeneralExploitsSection:Button({
    Title = "Chuva de Veículos",
    Desc = "Lança veículos no jogador selecionado",
    Callback = function()
        local success, message = ExploitModule.VehicleRain()
        WindUI:Notify({
            Title = success and "Sucesso" or "Erro",
            Content = message,
            Icon = success and "cloud-rain" or "x"
        })
    end
})
    Services.Players.PlayerAdded:Connect(function()
        local updatedList = PlayerListModule.UpdatePlayerList()
        if PlayerDropdownExploit then
            PlayerDropdownExploit:Refresh(updatedList)
        end
    end)
    Services.Players.PlayerRemoving:Connect(function()
        local updatedList = PlayerListModule.UpdatePlayerList()
        if PlayerDropdownExploit then
            PlayerDropdownExploit:Refresh(updatedList)
        end
    end)
    local DestructionTab = Window:Tab({
        Title = "Destruição",
        Icon = "bomb",
        IconColor = Color3.fromRGB(138, 43, 226),
    })
    local DestructionSection = DestructionTab:Section({
        Title = "Exploits de Destruição",
    })
    State.Features.VehicleLauncher.toggle = DestructionSection:Toggle({
        Title = "Lançar Veículos",
        Desc = "Clique: Segurar | Y: Lançar",
Icon = "check",
Type = "Checkbox",
IconSize = 8*2,
        Callback = function(value)
            ExploitModule.ActivateVehicleLauncher(value)
            if value then
                WindUI:Notify({
                    Title = "Lançador Ativado",
                    Content = "Detecta automaticamente veículos\nClique: Segurar | Y: Lançar",
                    Icon = "car-front",
                    Duration = 5
                })
            end
        end
    })
    DestructionSection:Button({
        Title = "Matar Todos do Servidor",
        Desc = "Coloca cabeças na frente para matar",
        Callback = function()
            ExploitModule.KillAllServer()
            WindUI:Notify({
                Title = "Matar Todos",
                Content = "Cabeças posicionadas, pegue arma e atire",
                Icon = "skull"
            })
        end
    })
    DestructionSection:Button({
        Title = "Ativar Telecinese",
        Desc = "Carrega script de telecinese",
        Callback = function()
            if not loadstring then
                WindUI:Notify({
                    Title = "Erro",
                    Content = "loadstring não disponível",
                    Icon = "x"
                })
                return
            end
            Utils.SafeCall(function()
                loadstring(game:HttpGet(Config.externos.Telekinesis))()
            end)
        end
    })
    local CombatTab = Window:Tab({
        Title = "Combate",
        Icon = "hand-fist",
        IconColor = Color3.fromRGB(138, 43, 226),
    })
    local AimbotSection = CombatTab:Section({
        Title = "Aimbot",
    })
    local AimbotColorsSection = CombatTab:Section({
        Title = "Cores Aimbot",
    })
    local HitboxSection = CombatTab:Section({
        Title = "Hitbox Expander",
    })
    local HitboxColorsSection = CombatTab:Section({
        Title = "Cores Hitbox",
    })

AimbotSection:Button({
    Title = "Carregar Aimbot",
    Desc = "Carrega o sistema Exunys Aimbot",
    Callback = function()
        local success, message = CombatModule.LoadAimbot()
        WindUI:Notify({
            Title = success and "Sucesso" or "Erro",
            Content = message,
            Icon = success and "check" or "x"
        })
    end
})

State.Features.Aimbot.toggle = AimbotSection:Toggle({
    Title = "Ativar Aimbot",
    Desc = "Liga/desliga o aimbot.",
Icon = "check",
Type = "Checkbox",
IconSize = 8*2,
    Callback = function(value)
        State.Features.Aimbot.Enabled = value
        CombatModule.UpdateAimbotSettings()
    end
})

State.Features.Aimbot.showFOVToggle = AimbotSection:Toggle({
    Title = "Mostrar/Ocultar FOV",
    Desc = "Exibe ou oculta o círculo FOV (não afeta o aimbot)",
    Default = true,
    Callback = function(value)
        State.Features.Aimbot.ShowFOV = value
        CombatModule.UpdateAimbotSettings()
    end
})

AimbotSection:Slider({
    Title = "FOV Radius",
    Desc = "Raio do FOV",
    Step = 5,
    Value = {
        Min = 30,
        Max = 500,
        Default = 90,
    },
    Callback = function(value)
        State.Features.Aimbot.FOVRadius = value
        CombatModule.UpdateAimbotSettings()
    end
})

AimbotSection:Slider({
    Title = "Suavidade",
    Desc = "Velocidade da mira (maior = mais suave)",
    Step = 0.05,
    Value = {
        Min = 0.05,
        Max = 1,
        Default = 0.3,
    },
    Callback = function(value)
        State.Features.Aimbot.Smoothness = value
        CombatModule.UpdateAimbotSettings()
    end
})

AimbotSection:Toggle({
    Title = "Wall Check",
    Desc = "Não mira através de paredes",
Icon = "check",
Type = "Checkbox",
IconSize = 8*2,
    Callback = function(value)
        State.Features.Aimbot.WallCheck = value
        CombatModule.UpdateAimbotSettings()
    end
})

AimbotSection:Toggle({
    Title = "Friend Check",
    Desc = "Ignora amigos",
Icon = "check",
Type = "Checkbox",
IconSize = 8*2,
    Callback = function(value)
        State.Features.Aimbot.FriendCheck = value
        CombatModule.UpdateAimbotSettings()
    end
})

AimbotColorsSection:Colorpicker({
    Title = "Cor do FOV",
    Desc = "Cor do círculo FOV",
    Default = State.Features.Aimbot.FOVColor,
    Callback = function(value)
        State.Features.Aimbot.FOVColor = value
        CombatModule.UpdateAimbotSettings()
    end
})

State.Features.MagicBullet.toggle = AimbotSection:Toggle({
    Title = "Magic Bullet",
    Desc = "Requer Chams ativado",
Icon = "check",
Type = "Checkbox",
IconSize = 8*2,
    Callback = function(value)
        if value and not State.Features.Chams.active then
            WindUI:Notify({
                Title = "Erro",
                Content = "Ative o Chams primeiro!",
                Icon = "x"
            })
            State.Features.MagicBullet.toggle:Set(false)
            return
        end
        State.Features.MagicBullet.active = value
    end
})

State.Features.HeadHitboxExpander.toggle = HitboxSection:Toggle({
    Title = "Ativar Head Hitbox Expander",
    Desc = "Aumenta a área de acerto da cabeça",
Icon = "check",
Type = "Checkbox",
IconSize = 8*2,
    Callback = function(value)
        CombatModule.ActivateHeadHitboxExpander(value)
    end
})

HitboxSection:Slider({
    Title = "Tamanho da Head Hitbox",
    Desc = "Tamanho da área expandida",
    Step = 1,
    Value = {
        Min = 2,
        Max = 30,
        Default = 10,
    },
    Callback = function(value)
        CombatModule.SetHeadHitboxSize(value)
    end
})

HitboxSection:Slider({
    Title = "Transparência",
    Desc = "1 = completamente invisível (recomendado)",
    Step = 0.1,
    Value = {
        Min = 0,
        Max = 1,
        Default = 1,  -- ALTERADO
    },
    Callback = function(value)
        CombatModule.SetHeadHitboxTransparency(value)
    end
})

    local VehicleTab = Window:Tab({
        Title = "Veículos",
        Icon = "car-front",
        IconColor = Color3.fromRGB(138, 43, 226),
    })
    local VehicleSection = VehicleTab:Section({
        Title = "Configurações",
    })
    State.Features.AutoUnlock.toggle = VehicleSection:Toggle({
        Title = "Destrancar Todos (Auto)",
        Desc = "Destrava veículos A-Chassis automaticamente",
Icon = "check",
Type = "Checkbox",
IconSize = 8*2,
        Callback = function(value)
            ExploitModule.ActivateAutoUnlock(value)
        end
    })
    VehicleSection:Button({
        Title = "Destrancar Todos Agora",
        Desc = "Destrava veículos A-Chassis no alcance",
        Callback = function()
            local count = VehicleModule.UnlockAllVehicles()
            WindUI:Notify({
                Title = "Veículos",
                Content = count .. " veículo(s) A-Chassis destravado(s)!",
                Icon = "unlock"
            })
        end
    })
    VehicleSection:Slider({
        Title = "Alcance",
        Desc = "Distância em studs",
        Step = 10,
        Value = {
            Min = 50,
            Max = 500,
            Default = Config.Defaults.VehicleRange,
        },
        Callback = function(value)
            VehicleModule.SetUnlockRange(value)
        end
    })
    State.Features.VehicleDelete.toggle = VehicleSection:Toggle({
        Title = "Deletar Veículo Próximo",
        Desc = "Clique no veículo para deletar (afundar)",
Icon = "check",
Type = "Checkbox",
IconSize = 8*2,
        Callback = function(value)
            ExploitModule.ActivateVehicleDelete(value)
        end
    })
    VehicleSection:Button({
        Title = "Teleport Veículo Próximo",
        Desc = "Teleporta e entra no veículo mais próximo",
        Callback = function()
            ExploitModule.TeleportToNearestVehicle()
            WindUI:Notify({
                Title = "Teleport Veículo",
                Content = "Teleportado para veículo próximo",
                Icon = "car-front"
            })
        end
    })
    State.Features.VehicleFly.toggle = VehicleSection:Toggle({
        Title = "Voar com Carro",
        Desc = "Voar com veículo (W S A D Q E)",
Icon = "check",
Type = "Checkbox",
IconSize = 8*2,
        Callback = function(value)
            ExploitModule.ActivateVehicleFly(value)
        end
    })
    State.Features.VehicleNoclip.toggle = VehicleSection:Toggle({
        Title = "Atravessar Paredes com Carro",
        Desc = "Noclip com veículo",
        Locked = true,
Icon = "check",
Type = "Checkbox",
IconSize = 8*2,
        Callback = function(value)
            ExploitModule.ActivateVehicleNoclip(value)
        end
    })
    local PortaMalasSection = VehicleTab:Section({
        Title = "Sistema de Porta-Malas",
    })
    local vehicleDropdownsContainer = {}
    local function updatePortaMalas(vehicleData)
        for _, dropdown in pairs(vehicleDropdownsContainer) do
            if dropdown and dropdown.Destroy then
                pcall(function() dropdown:Destroy() end)
            end
        end
        vehicleDropdownsContainer = {}
        vehicleData = vehicleData or PortaMalasModule.GetVehicleData()
        if #vehicleData == 0 then
            if State.PortaMalas.statusLabel then
                pcall(function()
                    State.PortaMalas.statusLabel:Set({
                        Title = "Status: Nenhum veículo A-Chassis com porta-malas • " .. os.date("%H:%M:%S")
                    })
                end)
            end
            return
        end
        for _, data in ipairs(vehicleData) do
            if #data.items > 0 then
                local success, dropdown = pcall(function()
                    return PortaMalasSection:Dropdown({
                        Title = data.name,
                        Desc = data.itemCount .. " item(ns) no porta-malas",
                        Values = data.items,
                        Value = "",
                        Callback = function(value)
                            if value and value ~= "" then
                                local cloneSuccess, message = PortaMalasModule.CloneItem(value, data.name)
                                WindUI:Notify({
                                    Title = cloneSuccess and "Sucesso" or "Erro",
                                    Content = message,
                                    Icon = cloneSuccess and "check" or "x"
                                })
                            end
                        end
                    })
                end)
            if success and dropdown then
                    table.insert(vehicleDropdownsContainer, dropdown)
                end
            end
        end
        if State.PortaMalas.statusLabel then
            pcall(function()
                State.PortaMalas.statusLabel:Set({
                    Title = "Status: " .. #vehicleData .. " veículo(s) A-Chassis • " .. os.date("%H:%M:%S")
                })
            end)
        else
            local success, label = pcall(function()
                return PortaMalasSection:Section({
                    Title = "Status: " .. #vehicleData .. " veículo(s) A-Chassis • " .. os.date("%H:%M:%S"),
                })
            end)
            if success then
                State.PortaMalas.statusLabel = label
            end
        end
        State.PortaMalas.lastRefreshTime = tick()
        State.PortaMalas.isRefreshing = false
    end
    PortaMalasSection:Button({
        Title = "Iniciar Monitoramento",
        Desc = "Monitora mudanças nos porta-malas",
        Callback = function()
            PortaMalasModule.StartMonitoring(updatePortaMalas)
            WindUI:Notify({
                Title = "Monitoramento",
                Content = "Sistema ativado",
                Icon = "eye"
            })
        end
    })
    PortaMalasSection:Button({
        Title = "Parar Monitoramento",
        Desc = "Para o monitoramento",
        Callback = function()
            PortaMalasModule.StopMonitoring()
            WindUI:Notify({
                Title = "Monitoramento",
                Content = "Sistema desativado",
                Icon = "eye-off"
            })
        end
    })
    PortaMalasSection:Button({
        Title = "Atualizar Porta-Malas",
        Desc = "Recarrega a lista de veículos A-Chassis",
        Callback = function()
            if not State.PortaMalas.isRefreshing then
                State.PortaMalas.isRefreshing = true
                updatePortaMalas()
            end
        end
    })
    PortaMalasSection:Button({
        Title = "Limpar Clones",
        Desc = "Remove porta-malas clonados",
        Callback = function()
            local count = PortaMalasModule.ClearClonedTrunk()
            WindUI:Notify({
                Title = "Limpeza",
                Content = count > 0 and (count .. " item(ns) removido(s)") or "Nada para limpar",
                Icon = "trash-2"
            })
        end
    })
    task.wait(0.5)
    updatePortaMalas()
    local WeaponTab = Window:Tab({
        Title = "Weapon",
        Icon = "axe",
        IconColor = Color3.fromRGB(138, 43, 226),
    })
    local WeaponSection = WeaponTab:Section({
        Title = "Edição de Armas",
    })
    local selectedWeapon = nil
    local WeaponDropdown = WeaponSection:Dropdown({
        Title = "Selecionar Arma",
        Desc = "Escolha uma arma para editar",
        Values = WeaponModule.GetWeaponsList(),
        Value = "",
        Callback = function(value)
            selectedWeapon = value
        end
    })
    WeaponSection:Button({
        Title = "Atualizar Lista de Armas",
        Desc = "Recarrega as armas disponíveis",
        Callback = function()
            local updatedList = WeaponModule.GetWeaponsList()
            WeaponDropdown:Refresh(updatedList)
            WindUI:Notify({
                Title = "Lista Atualizada",
                Content = #updatedList .. " arma(s) encontrada(s)",
                Icon = "refresh-cw"
            })
        end
    })
    WeaponSection:Slider({
        Title = "Fire Rate",
        Desc = "Ajuste a taxa de disparo",
        Step = 50,
        Value = {
            Min = 100,
            Max = 2000,
            Default = 850,
        },
        Callback = function(value)
            if selectedWeapon then
                local weapon = LocalPlayer.Backpack:FindFirstChild(selectedWeapon) or LocalPlayer.Character:FindFirstChild(selectedWeapon)
                if weapon then
                    WeaponModule.SetFireRate(weapon, value)
                    WindUI:Notify({
                        Title = "Atualizado",
                        Content = "Fire Rate ajustado para " .. value,
                        Icon = "check"
                    })
                end
            end
        end
    })
    WeaponSection:Slider({
        Title = "Ammo",
        Desc = "Ajuste a munição",
        Step = 10,
        Value = {
            Min = 10,
            Max = 1000,
            Default = 30,
        },
        Callback = function(value)
            if selectedWeapon then
                local weapon = LocalPlayer.Backpack:FindFirstChild(selectedWeapon) or LocalPlayer.Character:FindFirstChild(selectedWeapon)
                if weapon then
                    WeaponModule.SetAmmo(weapon, value)
                    WindUI:Notify({
                        Title = "Atualizado",
                        Content = "Ammo ajustada para " .. value,
                        Icon = "check"
                    })
                end
            end
        end
    })
    WeaponSection:Slider({
        Title = "Bullets",
        Desc = "Ajuste o número de balas por tiro",
        Step = 1,
        Value = {
            Min = 1,
            Max = 20,
            Default = 1,
        },
        Callback = function(value)
            if selectedWeapon then
                local weapon = LocalPlayer.Backpack:FindFirstChild(selectedWeapon) or LocalPlayer.Character:FindFirstChild(selectedWeapon)
                if weapon then
                    WeaponModule.SetBullets(weapon, value)
                    WindUI:Notify({
                        Title = "Atualizado",
                        Content = "Bullets ajustado para " .. value,
                        Icon = "check"
                    })
                end
            end
        end
    })

    WeaponSection:Slider({
    Title = "Raio da Explosão",
    Desc = "Raio da explosão (balas explosivas)",
    Step = 5,
    Value = {Min = 10, Max = 300, Default = 70},
    Callback = function(value)
        if selectedWeapon then
            local weapon = LocalPlayer.Backpack:FindFirstChild(selectedWeapon) or LocalPlayer.Character:FindFirstChild(selectedWeapon)
            if weapon then
                WeaponModule.SetExplosionRadius(weapon, value)
            end
        end
    end
})

WeaponSection:Slider({
    Title = "Bullet Drop",
    Desc = "Gravidade da bala (valores negativos altos = drop rápido/lag)",
    Step = 10,
    Value = {Min = -10000, Max = 100, Default = 0},
    Callback = function(value)
        if selectedWeapon then
            local weapon = LocalPlayer.Backpack:FindFirstChild(selectedWeapon) or LocalPlayer.Character:FindFirstChild(selectedWeapon)
            if weapon then
                WeaponModule.SetBulletDrop(weapon, value)
            end
        end
    end
})

    WeaponSection:Slider({
        Title = "Penetration",
        Desc = "Ajuste a penetração da bala",
        Step = 10,
        Value = {
            Min = 0,
            Max = 500,
            Default = 100,
        },
        Callback = function(value)
            if selectedWeapon then
                local weapon = LocalPlayer.Backpack:FindFirstChild(selectedWeapon) or LocalPlayer.Character:FindFirstChild(selectedWeapon)
                if weapon then
                    WeaponModule.SetPenetration(weapon, value)
                    WindUI:Notify({
                        Title = "Atualizado",
                        Content = "Penetration ajustada para " .. value,
                        Icon = "check"
                    })
                end
            end
        end
    })
    WeaponSection:Slider({
        Title = "Head Damage",
        Desc = "Ajuste o dano na cabeça",
        Step = 10,
        Value = {
            Min = 50,
            Max = 500,
            Default = 100,
        },
        Callback = function(value)
            if selectedWeapon then
                local weapon = LocalPlayer.Backpack:FindFirstChild(selectedWeapon) or LocalPlayer.Character:FindFirstChild(selectedWeapon)
                if weapon then
                    WeaponModule.SetHeadDamage(weapon, value)
                    WindUI:Notify({
                        Title = "Atualizado",
                        Content = "Head Damage ajustado para " .. value,
                        Icon = "check"
                    })
                end
            end
        end
    })
    WeaponSection:Slider({
        Title = "Torso Damage",
        Desc = "Ajuste o dano no torso",
        Step = 10,
        Value = {
            Min = 20,
            Max = 300,
            Default = 50,
        },
        Callback = function(value)
            if selectedWeapon then
                local weapon = LocalPlayer.Backpack:FindFirstChild(selectedWeapon) or LocalPlayer.Character:FindFirstChild(selectedWeapon)
                if weapon then
                    WeaponModule.SetTorsoDamage(weapon, value)
                    WindUI:Notify({
                        Title = "Atualizado",
                        Content = "Torso Damage ajustado para " .. value,
                        Icon = "check"
                    })
                end
            end
        end
    })
    WeaponSection:Toggle({
        Title = "No Recoil",
        Desc = "Remove o recuo da arma",
Icon = "check",
Type = "Checkbox",
IconSize = 8*2,
        Callback = function(value)
            if selectedWeapon then
                local weapon = LocalPlayer.Backpack:FindFirstChild(selectedWeapon) or LocalPlayer.Character:FindFirstChild(selectedWeapon)
                if weapon then
                    WeaponModule.SetNoRecoil(weapon, value)
                    WindUI:Notify({
                        Title = "Atualizado",
                        Content = "No Recoil " .. (value and "ativado" or "desativado"),
                        Icon = "check"
                    })
                end
            end
        end
    })

    WeaponSection:Toggle({
    Title = "Tracer",
    Desc = "Ativa/desativa tracer nas balas",
    Callback = function(value)
        if selectedWeapon then
            local weapon = LocalPlayer.Backpack:FindFirstChild(selectedWeapon) or LocalPlayer.Character:FindFirstChild(selectedWeapon)
            if weapon then
                WeaponModule.SetTracer(weapon, value)
            end
        end
    end
})

    WeaponSection:Toggle({
        Title = "Balas Explosivas",
        Desc = "Balas causam explosões",
Icon = "check",
Type = "Checkbox",
IconSize = 8*2,
        Callback = function(value)
            if selectedWeapon then
                local weapon = LocalPlayer.Backpack:FindFirstChild(selectedWeapon) or LocalPlayer.Character:FindFirstChild(selectedWeapon)
                if weapon then
                    WeaponModule.SetExplosiveBullets(weapon, value)
                    WindUI:Notify({
                        Title = "Atualizado",
                        Content = "Balas Explosivas " .. (value and "ativadas" or "desativadas"),
                        Icon = "check"
                    })
                end
            end
        end
    })
    WeaponSection:Toggle({
        Title = "Balas Arco-Íris",
        Desc = "Balas com efeito arco-íris",
Icon = "check",
Type = "Checkbox",
IconSize = 8*2,
        Callback = function(value)
            if selectedWeapon then
                local weapon = LocalPlayer.Backpack:FindFirstChild(selectedWeapon) or LocalPlayer.Character:FindFirstChild(selectedWeapon)
                if weapon then
                    WeaponModule.SetRainbowBullets(weapon, value)
                    WindUI:Notify({
                        Title = "Atualizado",
                        Content = "Balas Arco-Íris " .. (value and "ativadas" or "desativadas"),
                        Icon = "check"
                    })
                end
            end
        end
    })
    WeaponSection:Toggle({
        Title = "Modo de Disparo Semi",
        Desc = "Alterna entre Semi e Auto",
Icon = "check",
Type = "Checkbox",
IconSize = 8*2,
        Callback = function(value)
            if selectedWeapon then
                local weapon = LocalPlayer.Backpack:FindFirstChild(selectedWeapon) or LocalPlayer.Character:FindFirstChild(selectedWeapon)
                if weapon then
                    WeaponModule.SetFireMode(weapon, value and "Semi" or "Auto")
                    WindUI:Notify({
                        Title = "Atualizado",
                        Content = "Modo de Disparo: " .. (value and "Semi" or "Auto"),
                        Icon = "check"
                    })
                end
            end
        end
    })
    WeaponSection:Toggle({
        Title = "Proteção Capacete",
        Desc = "Ativa proteção infinita no capacete",
Icon = "check",
Type = "Checkbox",
IconSize = 8*2,
        Callback = function(value)
            WeaponModule.SetHelmetProtection(value and 99e99 or 1)
            WindUI:Notify({
                Title = "Atualizado",
                Content = "Proteção Capacete " .. (value and "ativada" or "desativada"),
                Icon = "check"
            })
        end
    })
    WeaponSection:Toggle({
        Title = "Proteção Colete",
        Desc = "Ativa proteção infinita no colete",
Icon = "check",
Type = "Checkbox",
IconSize = 8*2,
        Callback = function(value)
            WeaponModule.SetVestProtection(value and 99e99 or 1)
            WindUI:Notify({
                Title = "Atualizado",
                Content = "Proteção Colete " .. (value and "ativada" or "desativada"),
                Icon = "check"
            })
        end
    })
    WeaponSection:Toggle({
        Title = "No Camera Shake",
        Desc = "Remove tremedeira da câmera",
Icon = "check",
Type = "Checkbox",
IconSize = 8*2,
        Callback = function(value)
            WeaponModule.SetNoCameraShake(value)
            WindUI:Notify({
                Title = "Atualizado",
                Content = "No Camera Shake " .. (value and "ativado" or "desativado"),
                Icon = "check"
            })
        end
    })
    WeaponSection:Button({
        Title = "Force Fix Arma",
        Desc = "Corrige arma selecionada",
        Callback = function()
            if selectedWeapon then
                WeaponModule.forceFix(selectedWeapon)
                WindUI:Notify({
                    Title = "Atualizado",
                    Content = "Force Fix aplicado em " .. selectedWeapon,
                    Icon = "check"
                })
            end
        end
    })

    WeaponSection:Colorpicker({
    Title = "Cor do Tracer",
    Default = Color3.fromRGB(255, 2, 6),
    Callback = function(value)
        if selectedWeapon then
            local weapon = LocalPlayer.Backpack:FindFirstChild(selectedWeapon) or LocalPlayer.Character:FindFirstChild(selectedWeapon)
            if weapon then
                WeaponModule.SetTracerColor(weapon, value)
            end
        end
    end
})

    local HubsTab = Window:Tab({
        Title = "Hubs",
        Icon = "squares-exclude",
        IconColor = Color3.fromRGB(138, 43, 226),
    })
    HubsTab:Button({
        Title = "IY Remodel",
        Desc = "Carrega Infinite Yield Remodel",
        Callback = function()
            if not loadstring then
                WindUI:Notify({
                    Title = "Erro",
                    Content = "loadstring não disponível",
                    Icon = "x"
                })
                return
            end
            Utils.SafeCall(function()
                loadstring(game:HttpGet(Config.externos.IYRemodel))()
            end)
        end
    })
    HubsTab:Button({
        Title = "Pedroxz Menu",
        Desc = "Carrega menu do Pedroxz",
        Callback = function()
            if not loadstring then
                WindUI:Notify({
                    Title = "Erro",
                    Content = "loadstring não disponível",
                    Icon = "x"
                })
                return
            end
            Utils.SafeCall(function()
                loadstring(game:HttpGet(Config.externos.PedroxzMenu))()
            end)
        end
    })
    Window:Divider()
    local SettingsTab = Window:Tab({
        Title = "Configurações",
        Icon = "settings",
        IconColor = Color3.fromRGB(138, 43, 226),
    })
    SettingsTab:Section({
        Title = "Controles do Menu",
        Icon = "keyboard",
    })
    SettingsTab:Section({
        Title = Utils.IsMobile() and "3 Dedos (2x) - Ocultar/Mostrar" or "Tecla F3 - Ocultar/Mostrar",
    })

SettingsTab:Section({Title = "Usuário"})
SettingsTab:Toggle({
    Title = "Anônimo",
    Desc = "Ativa/desativa modo anônimo",
    Default = false,
    Callback = function(value)
        Config.User.Anonymous = value
    end
})

    local DangerZoneSection = SettingsTab:Section({
        Title = "Área de telagem",
        Icon = "triangle-alert",
    })
    SettingsTab:Button({
        Title = "Bypass Telagem",
        Desc = "Desliga todos os exploits ativos",
        Callback = function()
            BypassTelagem(WindUI)
        end
    })
end
-- ==========================================
-- VERIFICAÇÃO DE USUÁRIO
-- ==========================================
local function IsUserAllowed()
    local success, response = pcall(function()
        return game:HttpGet(Config.AllowedUsersURL)
    end)
    if not success then
        return false
    end
    local allowed = {}
    for line in response:gmatch("[^\r\n]+") do
        local trimmed = line:match("^%s*(.-)%s*$")
        if trimmed ~= "" and not trimmed:match("^#") then
            allowed[trimmed] = true
        end
    end
    return allowed[LocalPlayer.Name] or false
end
-- ==========================================
-- INICIALIZAÇÃO DA UI
-- ==========================================
local function InitializeMainUI(WindUI)
    if not IsUserAllowed() then
        WindUI:Notify({
            Title = "Acesso Negado",
            Content = "Você não está autorizado a usar este menu. Contate o administrador.",
            Icon = "x",
            Duration = 10
        })
        return
    end
    WindUI:AddTheme({
        Name = "DN Softwares Purple",
        Accent = WindUI:Gradient({
            ["0"] = { Color = Color3.fromHex("#2e1065"), Transparency = 0 },
            ["100"] = { Color = Color3.fromHex("#0a0a0a"), Transparency = 0 },
        }, { Rotation = 90 }),
        Background = Color3.fromHex("#0a0a0a"),
        BackgroundTransparency = 0,
        Outline = Color3.fromHex("#4c1d95"),
        Text = Color3.fromHex("#e4e4ff"),
        Placeholder = Color3.fromHex("#71717a"),
        Button = Color3.fromHex("#8a2be2"),
        Icon = Color3.fromHex("#efefef"),
        Hover = Color3.fromHex("#efefef"),
        WindowBackground = Color3.fromHex("#0a0a0a"),
        WindowShadow = Color3.fromHex("#000000"),
        DialogBackground = Color3.fromHex("#0a0a0a"),
        TabBackground = Color3.fromHex("#0a0a0a"),
        ElementBackground = Color3.fromHex("#0a0a0a"),
        PopupBackground = Color3.fromHex("#0a0a0a"),
        Toggle = Color3.fromHex("#0a0a0a"),
        ToggleBar = Color3.fromHex("#8a2be2"),
        Checkbox = Color3.fromHex("#8a2be2"),
        CheckboxIcon = Color3.fromHex("#efefef"),
        Slider = Color3.fromHex("#6422a1"),
        SliderThumb = Color3.fromHex("#8a2be2"),
        Glow = true,
    })
    WindUI:SetTheme("DN Softwares Purple")
local Window = WindUI:CreateWindow({
    Title = gradient("DN Menu", Color3.fromHex("#6E1FB8"), Color3.fromHex("#AB52FF")),
    Icon = "rbxassetid://81127879201153",
    IconSize = 19*2,
    Author = gradient("DN Softwares", Color3.fromHex("#EBEBEB"), Color3.fromHex("#9C9C9C")),
    Folder = "DNMenuConfig",
    NewElements = false,
    Size = UDim2.fromOffset(580, 460),
    Transparent = true,
    Theme = "DN Softwares Purple",
    User = Config.User,
})

    State.UI.window = Window
    task.spawn(function()
        for _, gui in ipairs(PlayerGui:GetChildren()) do
            if gui:IsA("ScreenGui") and gui:FindFirstChild("Holder") then
                State.UI.screenGui = gui
                break
            end
        end
    end)


    Window:EditOpenButton({
        Title = "DN Menu",
        Icon = "rbxassetid://81127879201153",
        CornerRadius = UDim.new(0, 20),
        StrokeThickness = 2,
        Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, Color3.fromHex("#090909")),
            ColorSequenceKeypoint.new(1, Color3.fromHex("#181818"))
        }),
        OnlyMobile = true,
        Enabled = true,
        Draggable = true,
    })
    SetupToggleVisibility(Window)
    SetupAutoCleanup(Window)
    AuthModule.StartAuthVerification()
    task.spawn(function()
        task.wait(1.5)
        local success = pcall(function()
            if request then
                request({
                    Url = "http://localhost:6463/rpc?v=1",
                    Method = "POST",
                    Headers = {["Content-Type"] = "application/json"},
                    Body = Services.HttpService:JSONEncode({
                        cmd = "INVITE_BROWSER",
                        args = {code = "vBPFAg8kHW"},
                        nonce = tostring(math.random(100000, 999999))
                    })
                })
            end
        end)
        if not success then
            setclipboard(Config.DiscordInvite)
        end
    end)
    AddMenuElements(Window, WindUI)
end
local function Main()
    if not LocalPlayer.Character then
        LocalPlayer.CharacterAdded:Wait()
    end
    local success, result = pcall(function()
        return loadstring(game:HttpGet("https://raw.githubusercontent.com/Footagesus/WindUI/main/dist/main.lua"))()
    end)
    if not success then
        warn("[DN Menu] Erro ao carregar WindUI:", result)
        return
    end
    local WindUI = result
    if not WindUI then
        warn("[DN Menu] WindUI retornou nil")
        return
    end
    InitializeMainUI(WindUI)
end
    Main()

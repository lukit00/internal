-- ==========================================
-- DN MENU - CAPITAL RJ PROFESSIONAL
-- Versão: 4.5.4 (A-CHASSIS SYSTEM) - OTIMIZADO E CORRIGIDO
-- Autor: Daniel Lukit (@xdn7) - Modificado conforme instruções
-- ==========================================
-- Carregar bypass AC universal primeiro
local Services = {
    Players = game:GetService("Players"),
    RunService = game:GetService("RunService"),
    UserInputService = game:GetService("UserInputService"),
    TweenService = game:GetService("TweenService"),
    Workspace = game:GetService("Workspace"),
    Lighting = game:GetService("Lighting"),
    HttpService = game:GetService("HttpService"),
    ReplicatedStorage = game:GetService("ReplicatedStorage"),
    CoreGui = game:GetService("CoreGui"),
    CollectionService = game:GetService("CollectionService"),
}
local LocalPlayer = Services.Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
-- CONFIGURAÇÃO
local Config = {
    Version = "4.5.4",
    Author = "@_dndev",
    Title = "DN Menu",
    AllowedUsersURL = "https://raw.githubusercontent.com/lukit00/internal/refs/heads/main/authorizeds",
    DiscordInvite = "https://discord.gg/vBPFAg8kHW",
    Colors = {
        Main = Color3.fromRGB(138, 43, 226),
        Secondary = Color3.fromRGB(75, 0, 130),
        Success = Color3.fromRGB(46, 204, 113),
        Warning = Color3.fromRGB(241, 196, 15),
        Error = Color3.fromRGB(231, 76, 60),
        Info = Color3.fromRGB(52, 152, 219)
    },
    Defaults = {
        Speed = 16,
        VehicleRange = 100,
        CameraFOV = 70,
    },
    Performance = {
        VehicleCacheInterval = 20,
        ESPUpdateRate = 0.5,
        MaxESPDistance = 300,
        MaxVehicleDistance = 200,
        AutoDisableOnLowFPS = true,
        LowFPSThreshold = 25,
    },
    User = {
        Enabled = true,
        Anonymous = false,
        Callback = function()
            return {
                Discord = "DN Menu User",
                Description = "Acesso restrito a usuários específicos"
            }
        end,
    },
    externos = {
        Telekinesis = "https://raw.githubusercontent.com/randomstring0/Qwerty/refs/heads/main/qwerty1.lua",
        IYRemodel = "https://raw.githubusercontent.com/froumes/badinfiniteyield/refs/heads/master/source",
        PedroxzMenu = "https://raw.githubusercontent.com/Pedroxz63/PedroxzMenuAtualizado/refs/heads/main/pedroxzmenuv.2.0.2.md",
    }
}
-- ESTADO
local State = {
    Features = {
        Speed = {active = false, value = Config.Defaults.Speed, toggle = nil},
        Godmode = {active = false, toggle = nil},
        CameraFOV = Config.Defaults.CameraFOV,
        ESP = {
            active = false,
            connections = {},
            billboards = {},
            color = Color3.fromRGB(138, 43, 226),
            toggle = nil,
            updateRate = Config.Performance.ESPUpdateRate
        },
        ESPSkeleton = {
            active = false,
            connections = {},
            lines = {},
            color = Color3.fromRGB(138, 43, 226),
            toggle = nil
        },
        ESPRGB = {
            active = false,
            toggle = nil
        },
        ESPAdmin = {
            active = false,
            adminColor = Color3.fromRGB(255, 0, 0),
            toggle = nil,
            connections = {},
            billboards = {},
            maxDistance = 500
        },
        Chams = {
            active = false,
            folder = nil,
            fillColor = Color3.fromRGB(138, 43, 226),
            outlineColor = Color3.fromRGB(75, 0, 130),
            toggle = nil
        },
        Fullbright = {active = false, original = {}, toggle = nil},
        GunPull = {active = false, connection = nil, toggle = nil, lastPull = 0, pullRate = 0.5},
        Exorcismo = {
            active = false,
            connection = nil,
            originalAnimateScript = nil,
            toggle = nil,
            backupAnimations = {}
        },
        BangPlayer = {
            active = false,
            connection = nil,
            target = nil,
            toggle = nil,
            bangSpeed = 0.15,
            bangDistance = 1.5,
            isMovingBack = false
        },
        VehicleLauncher = {
            active = false,
            connection = nil,
            selectedVehicle = nil,
            onHead = false,
            toggle = nil,
            holding = false,
            alignPosition = nil,
            alignOrientation = nil,
            attachment0 = nil,
            attachment1 = nil,
            animTrack = nil
        },
        Aimbot = {
            Enabled = false,
            ShowFOV = true,
            FOVWidth = 180,
            FOVHeight = 180,
            FOVThickness = 2,
            FOVColor = Color3.fromRGB(138, 43, 226),
            SilentEnabled = false,
            SilentFOVWidth = 180,
            SilentFOVHeight = 180,
            SilentFOVThickness = 2,
            SilentFOVColor = Color3.fromRGB(255, 0, 0),
            MaxDistance = 500,
            WallCheck = false,
            Smoothness = 0.2,
            Locked = nil,
            IsMobile = Services.UserInputService.TouchEnabled and not Services.UserInputService.KeyboardEnabled,
            Friends = {}
        },
        HitboxExpander = {
            active = false,
            size = 10,
            transparency = 0.5,
            toggle = nil,
            originalSizes = {}
        },
        Noclip = {
            active = false,
            connection = nil,
            toggle = nil
        },
        SoloSession = {
            active = false,
            oldPos = nil,
            oldCamType = nil,
            oldCamCFrame = nil,
            toggle = nil
        },
        AutoUnlock = {
            active = false,
            connection = nil,
            toggle = nil,
            lastUnlock = 0,
            unlockRate = 0.5
        },
        VehicleDelete = {
            active = false,
            connection = nil,
            toggle = nil
        },
        VehicleFly = {
            active = false,
            speed = 50,
            keys = {},
            connections = {},
            bodyForce = nil,
            toggle = nil
        },
        VehicleNoclip = {
            active = false,
            connection = nil,
            toggle = nil
        },
        LowLagMode = {
            active = false,
            toggle = nil
        }
    },
    Players = {
        list = {},
        selected = nil
    },
    Vehicles = {
        unlockRange = Config.Defaults.VehicleRange,
        cache = {},
        lastCacheUpdate = 0,
        cacheUpdateInterval = Config.Performance.VehicleCacheInterval
    },
    PortaMalas = {
        pulling = false,
        vehicleData = {},
        statusLabel = nil,
        monitorConnection = nil,
        isRefreshing = false,
        lastRefreshTime = 0
    },
    UI = {
        window = nil,
        screenGui = nil
    },
    Auth = {
        verificationConnection = nil,
        lastCheck = 0,
        checkInterval = 50
    },
    Friends = {}
}
-- ==========================================
-- UTILIDADES
-- ==========================================
local Utils = {}
function Utils.SafeCall(func, ...)
    local success, result = pcall(func, ...)
    if not success then
        warn("[DN Menu] Error:", result)
        return false, result
    end
    return true, result
end
function Utils.GetCharacter(player)
    player = player or LocalPlayer
    return player and player.Character
end
function Utils.GetHumanoid(player)
    local char = Utils.GetCharacter(player)
    return char and char:FindFirstChildOfClass("Humanoid")
end
function Utils.GetRootPart(player)
    local char = Utils.GetCharacter(player)
    return char and char:FindFirstChild("HumanoidRootPart")
end
function Utils.GetDistance(pos1, pos2)
    if not pos1 or not pos2 then return math.huge end
    return (pos1 - pos2).Magnitude
end
function Utils.ClearConnections(tbl)
    if type(tbl) ~= "table" then return end
    for i, conn in ipairs(tbl) do
        if conn and typeof(conn) == "RBXScriptConnection" then
            Utils.SafeCall(function() conn:Disconnect() end)
        end
        tbl[i] = nil
    end
end
function Utils.IsMobile()
    return Services.UserInputService.TouchEnabled and not Services.UserInputService.KeyboardEnabled
end
-- ==========================================
-- SISTEMA A-CHASSIS - FUNÇÕES PRINCIPAIS
-- ==========================================
function Utils.IsAChassis(model)
    if not model or not model:IsA("Model") then return false end
    return model:FindFirstChild("A-Chassis Tune", true) ~= nil
end
function Utils.UpdateVehicleCache(force)
    local currentTime = tick()
    if not force and currentTime - State.Vehicles.lastCacheUpdate < State.Vehicles.cacheUpdateInterval then return end
    State.Vehicles.lastCacheUpdate = currentTime
    local vehicles = {}
    local processed = {}
    for _, obj in ipairs(Services.Workspace:GetChildren()) do -- Reduzir escopo para GetChildren em vez de GetDescendants
        if obj:IsA("Model") and not processed[obj] and Utils.IsAChassis(obj) then
            table.insert(vehicles, obj)
            processed[obj] = true
        end
    end
    State.Vehicles.cache = vehicles
end
function Utils.GetAllAChassis()
    Utils.UpdateVehicleCache()
    return State.Vehicles.cache
end
function Utils.FindAChassisVehicle(vehicleName)
    Utils.UpdateVehicleCache()
    for _, vehicle in ipairs(State.Vehicles.cache) do
        if vehicle.Name == vehicleName or vehicle.Name:match(vehicleName) then
            return vehicle
        end
    end
    return nil
end
function Utils.GetVehicleMainPart(vehicle)
    if not vehicle then return nil end
    local vehicleSeat = vehicle:FindFirstChild("VehicleSeat", true)
    if vehicleSeat then return vehicleSeat end
    local driveSeat = vehicle:FindFirstChild("DriveSeat", true)
    if driveSeat then return driveSeat end
    for _, obj in ipairs(vehicle:GetChildren()) do -- Otimizado para GetChildren
        if obj:IsA("VehicleSeat") or obj:IsA("Seat") then
            return obj
        end
    end
    return vehicle:FindFirstChildWhichIsA("BasePart", true)
end
function Utils.GetNearestVehicle()
    local hrp = Utils.GetRootPart()
    if not hrp then return nil end
    local minDist = math.huge
    local nearest = nil
    Utils.UpdateVehicleCache()
    for _, vehicle in ipairs(State.Vehicles.cache) do
        local main = Utils.GetVehicleMainPart(vehicle)
        if main then
            local dist = Utils.GetDistance(hrp.Position, main.Position)
            if dist < minDist then
                minDist = dist
                nearest = vehicle
            end
        end
    end
    return nearest
end
-- ==========================================
-- MÓDULO JOGADOR (BOTÕES LOCKED)
-- ==========================================
local PlayerModule = {}
function PlayerModule.ActivateSpeed(enabled)
    -- Função vazia - mantida para compatibilidade com toggle locked
end
function PlayerModule.SetSpeed(value)
    State.Features.Speed.value = value
end
function PlayerModule.ActivateGodmode(enabled)
    -- Função vazia - mantida para compatibilidade com toggle locked
end
function PlayerModule.ActivateNoclip(enabled)
    local feature = State.Features.Noclip
    feature.active = enabled
    if enabled then
        local lastNoclipUpdate = 0
        feature.connection = Services.RunService.Stepped:Connect(function()
            if tick() - lastNoclipUpdate < 0.15 then return end
            lastNoclipUpdate = tick()
            local char = Utils.GetCharacter()
            if char then
                for _, part in ipairs(char:GetChildren()) do -- Otimizado
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end
            end
        end)
    else
        if feature.connection then
            feature.connection:Disconnect()
            feature.connection = nil
        end
    end
end
function PlayerModule.ActivateSoloSession(enabled)
    -- Função vazia - mantida para compatibilidade com toggle locked
end
function PlayerModule.SetCameraFOV(value)
    State.Features.CameraFOV = value
    if workspace.CurrentCamera then
        workspace.CurrentCamera.FieldOfView = value
    end
end
-- ==========================================
-- MÓDULO VISUAL - OTIMIZADO
-- ==========================================
local VisualModule = {}
function VisualModule.CreateESP(targetPlayer)
    if targetPlayer == LocalPlayer or not targetPlayer then return end
    local function setupESP()
        local char = Utils.GetCharacter(targetPlayer)
        if not char then return end
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        local oldESP = char:FindFirstChild("DNMenuESP")
        if oldESP then oldESP:Destroy() end
        local billboard = Instance.new("BillboardGui")
        billboard.Name = "DNMenuESP"
        billboard.Adornee = hrp
        billboard.Size = UDim2.new(0, 100, 0, 25)
        billboard.StudsOffset = Vector3.new(0, 3, 0)
        billboard.AlwaysOnTop = true
        billboard.Parent = char
        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(1, 0, 1, 0)
        label.BackgroundTransparency = 1
        label.TextColor3 = State.Features.ESP.color
        label.TextStrokeTransparency = 0.5
        label.TextScaled = true
        label.Font = Enum.Font.GothamBold
        label.Parent = billboard
        State.Features.ESP.billboards[targetPlayer.UserId] = {billboard = billboard, label = label, lastUpdate = 0}
    end
    if targetPlayer.Character then
        setupESP()
    end
    local charAddedConn = targetPlayer.CharacterAdded:Connect(function()
        if State.Features.ESP.active then
            task.wait(0.5)
            setupESP()
        end
    end)
    table.insert(State.Features.ESP.connections, charAddedConn)
end
function VisualModule.ActivateESP(enabled)
    local feature = State.Features.ESP
    feature.active = enabled
    if enabled then
        Utils.ClearConnections(feature.connections)
        feature.connections = {}
        for userid, data in pairs(feature.billboards) do
            if data.billboard then data.billboard:Destroy() end
        end
        feature.billboards = {}
        for _, player in ipairs(Services.Players:GetPlayers()) do
            if player ~= LocalPlayer then
                VisualModule.CreateESP(player)
            end
        end
        table.insert(feature.connections, Services.Players.PlayerAdded:Connect(function(player)
            if feature.active then
                task.wait(0.5)
                VisualModule.CreateESP(player)
            end
        end))
        table.insert(feature.connections, Services.Players.PlayerRemoving:Connect(function(player)
            local data = feature.billboards[player.UserId]
            if data and data.billboard then
                data.billboard:Destroy()
            end
            feature.billboards[player.UserId] = nil
        end))
        local lastUpdateTime = 0
        table.insert(feature.connections, Services.RunService.Heartbeat:Connect(function(dt)
            lastUpdateTime = lastUpdateTime + dt
            if lastUpdateTime < feature.updateRate then return end
            lastUpdateTime = 0
            local myHRP = Utils.GetRootPart()
            local color = feature.color
            if State.Features.ESPRGB.active then
                color = Color3.fromHSV((tick() % 5) / 5, 1, 1)
            end
            for userid, data in pairs(feature.billboards) do
                local player = Services.Players:GetPlayerByUserId(userid)
                if player and data.billboard and data.billboard.Parent then
                    local char = player.Character
                    local hrp = char and char:FindFirstChild("HumanoidRootPart")
                    if char and hrp then
                        data.label.TextColor3 = color
                        if myHRP then
                            local dist = Utils.GetDistance(myHRP.Position, hrp.Position)
                            data.label.Text = string.format("%s - %dm", player.Name, math.floor(dist))
                        end
                    else
                        data.billboard:Destroy()
                        feature.billboards[userid] = nil
                    end
                else
                    feature.billboards[userid] = nil
                end
            end
        end))
    else
        Utils.ClearConnections(feature.connections)
        feature.connections = {}
        for _, data in pairs(feature.billboards) do
            if data.billboard then data.billboard:Destroy() end
        end
        feature.billboards = {}
        for _, player in ipairs(Services.Players:GetPlayers()) do
            if player.Character then
                local esp = player.Character:FindFirstChild("DNMenuESP")
                if esp then esp:Destroy() end
            end
        end
    end
end
function VisualModule.UpdateESPColor(color)
    State.Features.ESP.color = color
    for _, data in pairs(State.Features.ESP.billboards) do
        if data.label then
            data.label.TextColor3 = color
        end
    end
end
function VisualModule.CreateESPSkeleton(targetPlayer)
    if targetPlayer == LocalPlayer or not targetPlayer then return end
    local function setupSkeleton()
        local char = Utils.GetCharacter(targetPlayer)
        if not char then return end
        local lines = {}
        local bonePairs = {
            {"Head", "UpperTorso"},
            {"UpperTorso", "LowerTorso"},
            {"UpperTorso", "LeftUpperArm"},
            {"LeftUpperArm", "LeftLowerArm"},
            {"LeftLowerArm", "LeftHand"},
            {"UpperTorso", "RightUpperArm"},
            {"RightUpperArm", "RightLowerArm"},
            {"RightLowerArm", "RightHand"},
            {"LowerTorso", "LeftUpperLeg"},
            {"LeftUpperLeg", "LeftLowerLeg"},
            {"LeftLowerLeg", "LeftFoot"},
            {"LowerTorso", "RightUpperLeg"},
            {"RightUpperLeg", "RightLowerLeg"},
            {"RightLowerLeg", "RightFoot"}
        }
        for _, pair in ipairs(bonePairs) do
            local line = Drawing.new("Line")
            line.Visible = false
            line.Color = State.Features.ESPSkeleton.color
            line.Thickness = 1
            line.Transparency = 1
            table.insert(lines, line)
        end
        State.Features.ESPSkeleton.lines[targetPlayer.UserId] = lines
    end
    if targetPlayer.Character then
        setupSkeleton()
    end
    local charAddedConn = targetPlayer.CharacterAdded:Connect(function()
        if State.Features.ESPSkeleton.active then
            task.wait(0.5)
            setupSkeleton()
        end
    end)
    table.insert(State.Features.ESPSkeleton.connections, charAddedConn)
end
function VisualModule.ActivateESPSkeleton(enabled)
    local feature = State.Features.ESPSkeleton
    feature.active = enabled
    if enabled then
        Utils.ClearConnections(feature.connections)
        feature.connections = {}
        for _, lines in pairs(feature.lines) do
            for _, line in pairs(lines) do
                if line then line:Remove() end
            end
        end
        feature.lines = {}
        for _, player in ipairs(Services.Players:GetPlayers()) do
            if player ~= LocalPlayer then
                VisualModule.CreateESPSkeleton(player)
            end
        end
        table.insert(feature.connections, Services.Players.PlayerAdded:Connect(function(player)
            if feature.active then
                VisualModule.CreateESPSkeleton(player)
            end
        end))
        table.insert(feature.connections, Services.Players.PlayerRemoving:Connect(function(player)
            local lines = feature.lines[player.UserId]
            if lines then
                for _, line in pairs(lines) do
                    if line then line:Remove() end
                end
                feature.lines[player.UserId] = nil
            end
        end))
        table.insert(feature.connections, Services.RunService.RenderStepped:Connect(function()
            for userid, lines in pairs(feature.lines) do
                local player = Services.Players:GetPlayerByUserId(userid)
                local char = player and player.Character
                if lines and char then
                    local humanoid = char:FindFirstChildOfClass("Humanoid")
                    if humanoid and humanoid.Health > 0 then
                        local bonePairs = {
                            {"Head", "UpperTorso"},
                            {"UpperTorso", "LowerTorso"},
                            {"UpperTorso", "LeftUpperArm"},
                            {"LeftUpperArm", "LeftLowerArm"},
                            {"LeftLowerArm", "LeftHand"},
                            {"UpperTorso", "RightUpperArm"},
                            {"RightUpperArm", "RightLowerArm"},
                            {"RightLowerArm", "RightHand"},
                            {"LowerTorso", "LeftUpperLeg"},
                            {"LeftUpperLeg", "LeftLowerLeg"},
                            {"LeftLowerLeg", "LeftFoot"},
                            {"LowerTorso", "RightUpperLeg"},
                            {"RightUpperLeg", "RightLowerLeg"},
                            {"RightLowerLeg", "RightFoot"}
                        }
                        local camera = Services.Workspace.CurrentCamera
                        for i, pair in ipairs(bonePairs) do
                            local part1 = char:FindFirstChild(pair[1])
                            local part2 = char:FindFirstChild(pair[2])
                            if part1 and part2 then
                                local pos1, on1 = camera:WorldToViewportPoint(part1.Position)
                                local pos2, on2 = camera:WorldToViewportPoint(part2.Position)
                                if on1 and on2 then
                                    lines[i].From = Vector2.new(pos1.X, pos1.Y)
                                    lines[i].To = Vector2.new(pos2.X, pos2.Y)
                                    lines[i].Visible = true
                                else
                                    lines[i].Visible = false
                                end
                            else
                                lines[i].Visible = false
                            end
                        end
                    else
                        for _, line in pairs(lines) do
                            line.Visible = false
                        end
                    end
                end
            end
        end))
    else
        Utils.ClearConnections(feature.connections)
        for _, lines in pairs(feature.lines) do
            for _, line in pairs(lines) do
                if line then line:Remove() end
            end
        end
        feature.lines = {}
    end
end
function VisualModule.ActivateESPRGB(enabled)
    State.Features.ESPRGB.active = enabled
end
function VisualModule.CreateAdminESP(targetPlayer)
    if targetPlayer == LocalPlayer or not targetPlayer then return end
    local function setupAdminESP()
        local char = Utils.GetCharacter(targetPlayer)
        if not char then return end
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        local myHRP = Utils.GetRootPart()
        if myHRP then
            local dist = Utils.GetDistance(myHRP.Position, hrp.Position)
            if dist > State.Features.ESPAdmin.maxDistance then return end
        end
        local oldESP = char:FindFirstChild("DNMenuAdminESP")
        if oldESP then oldESP:Destroy() end
        local billboard = Instance.new("BillboardGui")
        billboard.Name = "DNMenuAdminESP"
        billboard.Adornee = hrp
        billboard.Size = UDim2.new(0, 100, 0, 25)
        billboard.StudsOffset = Vector3.new(0, 3, 0)
        billboard.AlwaysOnTop = true
        billboard.Parent = char
        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(1, 0, 1, 0)
        label.BackgroundTransparency = 1
        label.TextColor3 = State.Features.ESPAdmin.adminColor
        label.TextStrokeTransparency = 0.5
        label.TextScaled = true
        label.Font = Enum.Font.GothamBold
        label.Parent = billboard
        State.Features.ESPAdmin.billboards[targetPlayer.UserId] = {billboard = billboard, label = label, lastUpdate = 0}
    end
    if targetPlayer.Character then
        setupAdminESP()
    end
    local charAddedConn = targetPlayer.CharacterAdded:Connect(function()
        if State.Features.ESPAdmin.active then
            task.wait(0.5)
            setupAdminESP()
        end
    end)
    table.insert(State.Features.ESPAdmin.connections, charAddedConn)
end
function VisualModule.ActivateESPAdmin(enabled)
    local feature = State.Features.ESPAdmin
    feature.active = enabled
    if enabled then
        Utils.ClearConnections(feature.connections)
        feature.connections = {}
        for userid, data in pairs(feature.billboards) do
            if data.billboard then data.billboard:Destroy() end
        end
        feature.billboards = {}
        for _, player in ipairs(Services.Players:GetPlayers()) do
            if player ~= LocalPlayer then
                VisualModule.CreateAdminESP(player)
            end
        end
        table.insert(feature.connections, Services.Players.PlayerAdded:Connect(function(player)
            if feature.active then
                task.wait(0.5)
                VisualModule.CreateAdminESP(player)
            end
        end))
        table.insert(feature.connections, Services.Players.PlayerRemoving:Connect(function(player)
            local data = feature.billboards[player.UserId]
            if data and data.billboard then
                data.billboard:Destroy()
            end
            feature.billboards[player.UserId] = nil
        end))
        local lastUpdateTime = 0
        local updateInterval = State.Features.ESP.updateRate -- Reuse ESP rate
        table.insert(feature.connections, Services.RunService.Heartbeat:Connect(function(dt)
            lastUpdateTime = lastUpdateTime + dt
            if lastUpdateTime < updateInterval then return end
            lastUpdateTime = 0
            local myHRP = Utils.GetRootPart()
            for userid, data in pairs(feature.billboards) do
                local player = Services.Players:GetPlayerByUserId(userid)
                if player and data.billboard and data.billboard.Parent then
                    local char = player.Character
                    local hrp = char and char:FindFirstChild("HumanoidRootPart")
                    if char and hrp then
                        local isAdmin = false
                        local status = ""
                        local humanoid = Utils.GetHumanoid(player)
                        if humanoid then
                            if humanoid.FloorMaterial == Enum.Material.Air and hrp.Velocity.Magnitude > 10 then
                                isAdmin = true
                                status = "Voando"
                            end
                        end
                        if hrp.Transparency > 0.5 then
                            isAdmin = true
                            status = "Invisível"
                        end
                        if not isAdmin then
                            data.billboard:Destroy()
                            feature.billboards[userid] = nil
                            return
                        end
                        if myHRP then
                            local dist = Utils.GetDistance(myHRP.Position, hrp.Position)
                            if dist > feature.maxDistance then
                                data.billboard:Destroy()
                                feature.billboards[userid] = nil
                                return
                            end
                            data.label.Text = string.format("%s - %dm (%s)", player.Name, math.floor(dist), status)
                        end
                    else
                        data.billboard:Destroy()
                        feature.billboards[userid] = nil
                    end
                else
                    feature.billboards[userid] = nil
                end
            end
        end))
    else
        Utils.ClearConnections(feature.connections)
        feature.connections = {}
        for _, data in pairs(feature.billboards) do
            if data.billboard then data.billboard:Destroy() end
        end
        feature.billboards = {}
        for _, player in ipairs(Services.Players:GetPlayers()) do
            if player.Character then
                local esp = player.Character:FindFirstChild("DNMenuAdminESP")
                if esp then esp:Destroy() end
            end
        end
    end
end
function VisualModule.ActivateChams(enabled)
    local feature = State.Features.Chams
    feature.active = enabled
    if enabled then
        feature.folder = Instance.new("Folder")
        feature.folder.Name = "ChamsFolder"
        feature.folder.Parent = LocalPlayer.PlayerGui  -- Changed from CoreGui to PlayerGui to fix nil value error
        for _, player in ipairs(Services.Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local highlight = Instance.new("Highlight")
                highlight.Name = player.Name
                highlight.FillColor = feature.fillColor
                highlight.OutlineColor = feature.outlineColor
                highlight.FillTransparency = 0.5
                highlight.OutlineTransparency = 0
                highlight.Parent = feature.folder
                highlight.Adornee = player.Character
            end
        end
        table.insert(feature.connections, Services.Players.PlayerAdded:Connect(function(player)
            if feature.active then
                player.CharacterAdded:Connect(function(char)
                    task.wait(0.5)
                    local highlight = Instance.new("Highlight")
                    highlight.Name = player.Name
                    highlight.FillColor = feature.fillColor
                    highlight.OutlineColor = feature.outlineColor
                    highlight.FillTransparency = 0.5
                    highlight.OutlineTransparency = 0
                    highlight.Parent = feature.folder
                    highlight.Adornee = char
                end)
            end
        end))
    else
        if feature.folder then
            feature.folder:Destroy()
            feature.folder = nil
        end
    end
end
function VisualModule.UpdateChamsColors()
    local feature = State.Features.Chams
    if feature.folder then
        for _, highlight in ipairs(feature.folder:GetChildren()) do
            if highlight:IsA("Highlight") then
                highlight.FillColor = feature.fillColor
                highlight.OutlineColor = feature.outlineColor
            end
        end
    end
end
function VisualModule.ActivateFullbright(enabled)
    local feature = State.Features.Fullbright
    feature.active = enabled
    if enabled then
        feature.original = {
            Brightness = Services.Lighting.Brightness,
            ClockTime = Services.Lighting.ClockTime,
            FogEnd = Services.Lighting.FogEnd,
            GlobalShadows = Services.Lighting.GlobalShadows,
            OutdoorAmbient = Services.Lighting.OutdoorAmbient
        }
        Services.Lighting.Brightness = 2
        Services.Lighting.ClockTime = 14
        Services.Lighting.FogEnd = 100000
        Services.Lighting.GlobalShadows = false
        Services.Lighting.OutdoorAmbient = Color3.fromRGB(128, 128, 128)
    else
        if feature.original.Brightness then
            Services.Lighting.Brightness = feature.original.Brightness
            Services.Lighting.ClockTime = feature.original.ClockTime
            Services.Lighting.FogEnd = feature.original.FogEnd
            Services.Lighting.GlobalShadows = feature.original.GlobalShadows
            Services.Lighting.OutdoorAmbient = feature.original.OutdoorAmbient
        end
    end
end
-- ==========================================
-- MÓDULO EXPLOIT - OTIMIZADO
-- ==========================================
local ExploitModule = {}
function ExploitModule.AddFriend(playerName)
    if not table.find(State.Friends, playerName) then
        table.insert(State.Friends, playerName)
    end
end
function ExploitModule.RemoveFriend(playerName)
    for i, name in ipairs(State.Friends) do
        if name == playerName then
            table.remove(State.Friends, i)
            break
        end
    end
end
function ExploitModule.ActivateGunPull(enabled)
    local feature = State.Features.GunPull
    feature.active = enabled
    if enabled then
        if feature.connection then return end
        feature.connection = Services.RunService.Heartbeat:Connect(function()
            if not feature.active then
                Utils.ClearConnections({feature.connection})
                feature.connection = nil
                return
            end
            local currentTime = tick()
            if currentTime - feature.lastPull < feature.pullRate then return end
            feature.lastPull = currentTime
            Utils.SafeCall(function()
                for _, player in ipairs(Services.Players:GetPlayers()) do
                    if player ~= LocalPlayer and player:FindFirstChild("Backpack") then
                        for _, item in ipairs(player.Backpack:GetChildren()) do
                            if item:IsA("Tool") and item:FindFirstChild("ACS_Settings") and item.ACS_Settings:IsA("ModuleScript") then
                                item.Parent = LocalPlayer.Backpack
                            end
                        end
                    end
                end
            end)
        end)
    else
        Utils.ClearConnections({feature.connection})
        feature.connection = nil
    end
end
function ExploitModule.ActivateExorcismo(enabled)
    local feature = State.Features.Exorcismo
    feature.active = enabled
    if enabled then
        if feature.connection then return end
        local function onCharacterAdded(character)
            if not feature.active then return end
            task.wait(0.1)
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if not humanoid then return end
            if humanoid.RigType ~= Enum.HumanoidRigType.R15 then
                return
            end
            local animateScript = character:FindFirstChild("Animate")
            if not animateScript then return end
            if not feature.originalAnimateScript then
                feature.originalAnimateScript = animateScript:Clone()
            end
            feature.backupAnimations = {}
            for _, folder in ipairs(animateScript:GetChildren()) do
                if folder:IsA("StringValue") then
                    for _, anim in ipairs(folder:GetChildren()) do
                        if anim:IsA("Animation") then
                            local key = folder.Name .. "_" .. anim.Name
                            feature.backupAnimations[key] = anim.AnimationId
                        end
                    end
                end
            end
            local animator = humanoid:FindFirstChild("Animator")
            if animator then
                for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
                    track:Stop(0)
                end
            end
            local idle = animateScript:FindFirstChild("idle")
            local walk = animateScript:FindFirstChild("walk")
            local run = animateScript:FindFirstChild("run")
            if idle and idle:FindFirstChild("Animation1") then
                idle.Animation1.AnimationId = "http://www.roblox.com/asset/?id=80103653497738"
            end
            if idle and idle:FindFirstChild("Animation2") then
                idle.Animation2.AnimationId = "http://www.roblox.com/asset/?id=75794256017298"
            end
            if walk and walk:FindFirstChild("WalkAnim") then
                walk.WalkAnim.AnimationId = "http://www.roblox.com/asset/?id=88508412373927"
            end
            if run and run:FindFirstChild("RunAnim") then
                run.RunAnim.AnimationId = "http://www.roblox.com/asset/?id=88508412373927"
            end
            animateScript.Disabled = true
            task.wait(0.1)
            animateScript.Disabled = false
        end
        if LocalPlayer.Character then
            onCharacterAdded(LocalPlayer.Character)
        end
        feature.connection = LocalPlayer.CharacterAdded:Connect(onCharacterAdded)
    else
        Utils.ClearConnections({feature.connection})
        feature.connection = nil
        if LocalPlayer.Character then
            local char = LocalPlayer.Character
            local humanoid = char:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid:FindFirstChild("Animator") then
                local animator = humanoid.Animator
                for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
                    pcall(function() track:Stop(0) end)
                end
            end
            local currentAnimate = char:FindFirstChild("Animate")
            if currentAnimate then
                currentAnimate:Destroy()
            end
            if feature.originalAnimateScript then
                task.wait(0.3)
                local newAnimate = feature.originalAnimateScript:Clone()
                for key, animId in pairs(feature.backupAnimations) do
                    local folderName, animName = key:match("(.+)_(.+)")
                    if folderName and animName then
                        local folder = newAnimate:FindFirstChild(folderName)
                        if folder then
                            local anim = folder:FindFirstChild(animName)
                            if anim and anim:IsA("Animation") then
                                anim.AnimationId = animId
                            end
                        end
                    end
                end
                newAnimate.Parent = char
                newAnimate.Disabled = false
                task.wait(0.2)
                newAnimate.Disabled = true
                task.wait(0.1)
                newAnimate.Disabled = false
            end
        end
        feature.backupAnimations = {}
    end
end
function ExploitModule.ActivateBangPlayer(enabled)
    local feature = State.Features.BangPlayer
    feature.active = enabled
    if enabled then
        if not feature.target or not feature.target.Character then
            feature.active = false
            return
        end
        if feature.connection then return end
        local lastToggle = 0
        feature.connection = Services.RunService.Heartbeat:Connect(function()
            if not feature.active then
                Utils.ClearConnections({feature.connection})
                feature.connection = nil
                return
            end
            local currentTime = tick()
            if currentTime - lastToggle < feature.bangSpeed then return end
            lastToggle = currentTime
            Utils.SafeCall(function()
                local myHRP = Utils.GetRootPart()
                local targetHRP = Utils.GetRootPart(feature.target)
                if myHRP and targetHRP then
                    local targetCFrame = targetHRP.CFrame
                    local behindOffset = -targetCFrame.LookVector * 3
                    local bangOffset = targetCFrame.LookVector * (feature.isMovingBack and -feature.bangDistance or feature.bangDistance)
                    local finalPosition = targetCFrame.Position + behindOffset + bangOffset
                    myHRP.CFrame = CFrame.new(
                        finalPosition,
                        finalPosition + targetCFrame.LookVector
                    )
                    feature.isMovingBack = not feature.isMovingBack
                end
            end)
        end)
    else
        Utils.ClearConnections({feature.connection})
        feature.connection = nil
        feature.isMovingBack = false
    end
end
function ExploitModule.ActivateVehicleLauncher(enabled)
    local feature = State.Features.VehicleLauncher
    feature.active = enabled
    if enabled then
        local mouse = LocalPlayer:GetMouse()
        local function clearVehicle()
            if feature.alignPosition then
                feature.alignPosition:Destroy()
                feature.alignPosition = nil
            end
            if feature.alignOrientation then
                feature.alignOrientation:Destroy()
                feature.alignOrientation = nil
            end
            if feature.attachment0 then
                feature.attachment0:Destroy()
                feature.attachment0 = nil
            end
            if feature.attachment1 then
                feature.attachment1:Destroy()
                feature.attachment1 = nil
            end
            if feature.animTrack then
                feature.animTrack:Stop()
                feature.animTrack = nil
            end
            feature.selectedVehicle = nil
            feature.holding = false
        end
        mouse.Button1Down:Connect(function()
            if not feature.active then return end
            local target = mouse.Target
            if not target then return end
            local vehicle = target
            while vehicle and vehicle ~= Services.Workspace do
                if vehicle:IsA("Model") and Utils.IsAChassis(vehicle) then
                    break
                end
                vehicle = vehicle.Parent
            end
            if not vehicle or not Utils.IsAChassis(vehicle) then
                return
            end
            if vehicle.Name:lower():find("moto") then
                return
            end
            if feature.holding and feature.selectedVehicle == vehicle then
                return
            end
            clearVehicle()
            feature.selectedVehicle = vehicle
            feature.holding = true
            local mainPart = Utils.GetVehicleMainPart(vehicle)
            if not mainPart then return end
            local hrp = Utils.GetRootPart()
            if not hrp then return end
            -- Removido anchoring para evitar bugs e lag
            feature.attachment0 = Instance.new("Attachment")
            feature.attachment0.Parent = mainPart
            feature.attachment1 = Instance.new("Attachment")
            feature.attachment1.Parent = hrp
            feature.alignPosition = Instance.new("AlignPosition")
            feature.alignPosition.Attachment0 = feature.attachment0
            feature.alignPosition.Attachment1 = feature.attachment1
            feature.alignPosition.MaxForce = 9e9
            feature.alignPosition.MaxVelocity = math.huge
            feature.alignPosition.Responsiveness = 200
            feature.alignPosition.Parent = mainPart
            feature.alignOrientation = Instance.new("AlignOrientation")
            feature.alignOrientation.Attachment0 = feature.attachment0
            feature.alignOrientation.Attachment1 = feature.attachment1
            feature.alignOrientation.MaxTorque = 9e9
            feature.alignOrientation.Responsiveness = 200
            feature.alignOrientation.Parent = mainPart
            local humanoid = Utils.GetHumanoid()
            if humanoid then
                if feature.animTrack then
                    feature.animTrack:Stop()
                end
                local animation = Instance.new("Animation")
                animation.AnimationId = "rbxassetid://2510198475" -- Hands up animation (FE compatible)
                local animator = humanoid:FindFirstChildOfClass("Animator")
                if animator then
                    feature.animTrack = animator:LoadAnimation(animation)
                    feature.animTrack:Play()
                end
            end
        end)
        Services.UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if gameProcessed or not feature.active or not feature.selectedVehicle or not feature.holding then return end
            if input.KeyCode == Enum.KeyCode.Y then
                local hrp = Utils.GetRootPart()
                if not hrp then return end
                local mainPart = Utils.GetVehicleMainPart(feature.selectedVehicle)
                if not mainPart then return end
                -- Removido unanchoring desnecessário
                if feature.alignPosition then
                    feature.alignPosition:Destroy()
                    feature.alignPosition = nil
                end
                if feature.alignOrientation then
                    feature.alignOrientation:Destroy()
                    feature.alignOrientation = nil
                end
                if feature.attachment0 then
                    feature.attachment0:Destroy()
                    feature.attachment0 = nil
                end
                if feature.attachment1 then
                    feature.attachment1:Destroy()
                    feature.attachment1 = nil
                end
                local camera = Services.Workspace.CurrentCamera
                local launchDirection = camera.CFrame.LookVector
                local launchForce = Instance.new("BodyVelocity")
                launchForce.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                launchForce.Velocity = launchDirection * 350
                launchForce.Parent = mainPart
                task.delay(0.3, function()
                    if launchForce and launchForce.Parent then
                        launchForce:Destroy()
                    end
                end)
                if feature.animTrack then
                    feature.animTrack:Stop()
                    feature.animTrack = nil
                end
                feature.selectedVehicle = nil
                feature.holding = false
            end
        end)
        feature.connection = Services.RunService.Heartbeat:Connect(function()
            if not feature.active then
                clearVehicle()
                Utils.ClearConnections({feature.connection})
                feature.connection = nil
                return
            end
            if feature.selectedVehicle and feature.holding and feature.attachment1 then
                local hrp = Utils.GetRootPart()
                if not hrp then return end
                local mainPart = Utils.GetVehicleMainPart(feature.selectedVehicle)
                if not mainPart then
                    clearVehicle()
                    return
                end
                local upOffset = Vector3.new(0, 5, 0)
                local frontOffset = hrp.CFrame.LookVector * 0
                feature.attachment1.WorldPosition = hrp.Position + upOffset + frontOffset
                feature.attachment1.WorldCFrame = hrp.CFrame * CFrame.new(0, 5, 0)
            end
        end)
    else
        clearVehicle()
        Utils.ClearConnections({feature.connection})
        feature.connection = nil
    end
end
function ExploitModule.ActivateAutoUnlock(enabled)
    local feature = State.Features.AutoUnlock
    feature.active = enabled
    if enabled then
        feature.connection = Services.RunService.Heartbeat:Connect(function()
            if not feature.active then return end
            local currentTime = tick()
            if currentTime - feature.lastUnlock < feature.unlockRate then return end
            feature.lastUnlock = currentTime
            VehicleModule.UnlockAllVehicles()
        end)
    else
        if feature.connection then
            feature.connection:Disconnect()
            feature.connection = nil
        end
    end
end
function ExploitModule.ActivateVehicleDelete(enabled)
    local feature = State.Features.VehicleDelete
    feature.active = enabled
    if enabled then
        local mouse = LocalPlayer:GetMouse()
        feature.connection = mouse.Button1Down:Connect(function()
            if not feature.active then return end
            local target = mouse.Target
            if not target then return end
            local vehicle = target
            while vehicle and vehicle ~= Services.Workspace do
                if vehicle:IsA("Model") and Utils.IsAChassis(vehicle) then
                    break
                end
                vehicle = vehicle.Parent
            end
            if not vehicle then return end
            -- Use telekinesis logic to move model under ground
            local tool = LocalPlayer.Backpack:FindFirstChild("Telekinesis V6") or LocalPlayer.Character:FindFirstChild("Telekinesis V6")
            if not tool then
                loadstring(game:HttpGet(Config.externos.Telekinesis))()
                task.wait(0.5)
                tool = LocalPlayer.Backpack:FindFirstChild("Telekinesis V6")
            end
            if tool then
                tool.Parent = LocalPlayer.Character
                task.wait(0.1)
                -- Simulate telekinesis to move under ground
                local mainPart = Utils.GetVehicleMainPart(vehicle)
                if mainPart then
                    mainPart.CFrame = mainPart.CFrame * CFrame.new(0, -1000, 0)
                end
                tool.Parent = LocalPlayer.Backpack
            end
        end)
    else
        if feature.connection then
            feature.connection:Disconnect()
            feature.connection = nil
        end
    end
end
function ExploitModule.TeleportToNearestVehicle()
    local vehicle = Utils.GetNearestVehicle()
    if not vehicle then return end
    local main = Utils.GetVehicleMainPart(vehicle)
    if main and main:IsA("VehicleSeat") then
        local hrp = Utils.GetRootPart()
        if hrp then
            hrp.CFrame = main.CFrame * CFrame.new(0, 3, 0)
            task.wait(0.1)
            main:Sit(Utils.GetHumanoid())
        end
    end
end
function ExploitModule.ActivateVehicleFly(enabled)
    local feature = State.Features.VehicleFly
    feature.active = enabled
    local velocityHandlerName = "VehicleFlyVelocity32"
    local gyroHandlerName = "VehicleFlyGyro64"
    local VelocityHandler = nil
    local GyroHandler = nil
    local isAntiLockOn = false
    local FlyEnabled = false
    local flightWithoutFlyEnabled = false
    local isPitchOn = false
    local activeConnections = {}
    local movementDirection = {}
    local forwardVelocity = 100
    local leftVelocity = 100
    local rightVelocity = 100
    local upVelocity = 50
    local downVelocity = 50
    local rotationSpeed = 5
    local function setupFlyInstances(character)
        if not character or not character:FindFirstChild("HumanoidRootPart") then
            return
        end
        local existingVelocity = character.HumanoidRootPart:FindFirstChild(velocityHandlerName)
        local existingGyro = character.HumanoidRootPart:FindFirstChild(gyroHandlerName)
        if existingVelocity then
            existingVelocity:Destroy()
        end
        if existingGyro then
            existingGyro:Destroy()
        end
        VelocityHandler = Instance.new("BodyVelocity")
        VelocityHandler.Name = velocityHandlerName
        VelocityHandler.Parent = character.HumanoidRootPart
        VelocityHandler.MaxForce = Vector3.new(9e9, 9e9, 9e9)
        VelocityHandler.Velocity = Vector3.new()
        GyroHandler = Instance.new("BodyGyro")
        GyroHandler.Name = gyroHandlerName
        GyroHandler.Parent = character.HumanoidRootPart
        GyroHandler.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
        GyroHandler.P = 1000
        GyroHandler.D = 50
        GyroHandler.CFrame = character.HumanoidRootPart.CFrame
    end
    local function EnableFlight()
        local character = LocalPlayer.Character
        if character then
            setupFlyInstances(character)
        end
    end
    local function DisableFlight()
        if VelocityHandler then
            VelocityHandler:Destroy()
            VelocityHandler = nil
        end
        if GyroHandler then
            GyroHandler:Destroy()
            GyroHandler = nil
        end
    end
    local function cleanupConnections()
        for _, connection in pairs(activeConnections) do
            if connection and connection.Disconnect then
                connection:Disconnect()
            end
        end
        activeConnections = {}
    end
    local function handleInput()
        local character = LocalPlayer.Character
        if not character then
            return
        end
        local humanoid = character:FindFirstChild("Humanoid")
        if not humanoid then
            return
        end
        if FlyEnabled and (humanoid.SeatPart or flightWithoutFlyEnabled) then
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            if not rootPart then
                return
            end
            if not VelocityHandler then
                return
            end
            local gyro = rootPart:FindFirstChild(gyroHandlerName)
            local speed = 1 -- Default speed, adjust as needed
            local velocity = Vector3.new()
            local function getMovementCFrame()
                if isPitchOn and gyro then
                    return gyro.CFrame
                elseif gyro then
                    local lookVector = gyro.CFrame.LookVector
                    return CFrame.new(gyro.Parent.Position, gyro.Parent.Position + Vector3.new(lookVector.X, 0, lookVector.Z))
                end
                return rootPart.CFrame
            end
            local movementCFrame = getMovementCFrame()
            for _, direction in ipairs(movementDirection) do
                if direction == "forward" then
                    velocity += movementCFrame.LookVector * forwardVelocity
                elseif direction == "backward" then
                    velocity += -movementCFrame.LookVector * forwardVelocity
                elseif direction == "left" then
                    velocity += movementCFrame.RightVector * -leftVelocity
                elseif direction == "right" then
                    velocity += movementCFrame.RightVector * rightVelocity
                elseif direction == "up" then
                    velocity += Vector3.new(0, upVelocity, 0)
                elseif direction == "down" then
                    velocity += Vector3.new(0, -downVelocity, 0)
                elseif direction == "rotateLeft" and gyro then
                    gyro.CFrame = gyro.CFrame * CFrame.Angles(0, math.rad(-rotationSpeed), 0)
                elseif direction == "rotateRight" and gyro then
                    gyro.CFrame = gyro.CFrame * CFrame.Angles(0, math.rad(rotationSpeed), 0)
                end
            end
            local thumbstickDirection = Vector2.new(0, 0)
            pcall(function()
                local controlModule = require(LocalPlayer.PlayerScripts:WaitForChild("PlayerModule"):WaitForChild("ControlModule"))
                thumbstickDirection = controlModule:GetMoveVector()
            end)
            if #movementDirection > 0 or thumbstickDirection.Magnitude > 0 then
                local combinedVelocity = velocity + (
                    movementCFrame.RightVector * thumbstickDirection.X * forwardVelocity * 2 +
                    movementCFrame.LookVector * -thumbstickDirection.Z * forwardVelocity * 2
                )
                if isAntiLockOn and humanoid.SeatPart then
                    local seatForward = humanoid.SeatPart.CFrame.LookVector
                    local seatRight = humanoid.SeatPart.CFrame.RightVector
                    local seatUp = humanoid.SeatPart.CFrame.UpVector
                    local seatVelocity = Vector3.new()
                    for _, direction in ipairs(movementDirection) do
                        if direction == "forward" then
                            seatVelocity += seatForward * forwardVelocity
                        elseif direction == "backward" then
                            seatVelocity += -seatForward * forwardVelocity
                        elseif direction == "left" then
                            seatVelocity += -seatRight * leftVelocity
                        elseif direction == "right" then
                            seatVelocity += seatRight * rightVelocity
                        elseif direction == "up" then
                            seatVelocity += seatUp * upVelocity
                        elseif direction == "down" then
                            seatVelocity += -seatUp * downVelocity
                        end
                    end
                    VelocityHandler.Velocity = seatVelocity * speed
                else
                    VelocityHandler.Velocity = combinedVelocity * speed
                end
            else
                VelocityHandler.Velocity = Vector3.new()
            end
            if not isAntiLockOn then
                local camera = workspace.CurrentCamera
                if isPitchOn and gyro then
                    gyro.CFrame = camera.CFrame
                elseif gyro then
                    local flatLookVector = camera.CFrame.LookVector * Vector3.new(1, 0, 1)
                    gyro.CFrame = CFrame.new(gyro.Parent.Position, gyro.Parent.Position + flatLookVector)
                end
            end
        else
            if VelocityHandler then
                VelocityHandler.Velocity = Vector3.new()
            end
        end
    end
    if enabled then
        FlyEnabled = true
        EnableFlight()
        table.insert(activeConnections, Services.RunService.RenderStepped:Connect(handleInput))
        Services.UserInputService.InputBegan:Connect(function(input)
            if input.KeyCode == Enum.KeyCode.W then table.insert(movementDirection, "forward") end
            if input.KeyCode == Enum.KeyCode.S then table.insert(movementDirection, "backward") end
            if input.KeyCode == Enum.KeyCode.A then table.insert(movementDirection, "left") end
            if input.KeyCode == Enum.KeyCode.D then table.insert(movementDirection, "right") end
            if input.KeyCode == Enum.KeyCode.Space then table.insert(movementDirection, "up") end
            if input.KeyCode == Enum.KeyCode.LeftControl then table.insert(movementDirection, "down") end
            if input.KeyCode == Enum.KeyCode.Q then table.insert(movementDirection, "rotateLeft") end
            if input.KeyCode == Enum.KeyCode.E then table.insert(movementDirection, "rotateRight") end
        end)
        Services.UserInputService.InputEnded:Connect(function(input)
            if input.KeyCode == Enum.KeyCode.W then table.remove(movementDirection, table.find(movementDirection, "forward")) end
            if input.KeyCode == Enum.KeyCode.S then table.remove(movementDirection, table.find(movementDirection, "backward")) end
            if input.KeyCode == Enum.KeyCode.A then table.remove(movementDirection, table.find(movementDirection, "left")) end
            if input.KeyCode == Enum.KeyCode.D then table.remove(movementDirection, table.find(movementDirection, "right")) end
            if input.KeyCode == Enum.KeyCode.Space then table.remove(movementDirection, table.find(movementDirection, "up")) end
            if input.KeyCode == Enum.KeyCode.LeftControl then table.remove(movementDirection, table.find(movementDirection, "down")) end
            if input.KeyCode == Enum.KeyCode.Q then table.remove(movementDirection, table.find(movementDirection, "rotateLeft")) end
            if input.KeyCode == Enum.KeyCode.E then table.remove(movementDirection, table.find(movementDirection, "rotateRight")) end
        end)
    else
        FlyEnabled = false
        DisableFlight()
        cleanupConnections()
        movementDirection = {}
    end
end
function ExploitModule.ActivateVehicleNoclip(enabled)
    local feature = State.Features.VehicleNoclip
    feature.active = enabled
    if enabled then
        feature.connection = Services.RunService.Stepped:Connect(function()
            local currentTime = tick()
            if currentTime - (feature.lastUpdate or 0) < 0.1 then return end
            feature.lastUpdate = currentTime
            local humanoid = Utils.GetHumanoid()
            if not humanoid or not humanoid.SeatPart then return end
            local vehicle = humanoid.SeatPart.Parent
            for _, part in ipairs(vehicle:GetChildren()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end)
    else
        if feature.connection then
            feature.connection:Disconnect()
            feature.connection = nil
        end
    end
end
function ExploitModule.CleanPlayersWithVehicle()
    local player = State.Players.selected
    if not player then return end
    local char = Utils.GetCharacter(player)
    if not char then return end
    local humanoid = Utils.GetHumanoid(player)
    if not humanoid or not humanoid.SeatPart then return end
    -- Use telekinesis logic
    local tool = LocalPlayer.Backpack:FindFirstChild("Telekinesis V6") or LocalPlayer.Character:FindFirstChild("Telekinesis V6")
    if not tool then
        loadstring(game:HttpGet(Config.externos.Telekinesis))()
        task.wait(0.5)
        tool = LocalPlayer.Backpack:FindFirstChild("Telekinesis V6")
    end
    if tool then
        tool.Parent = LocalPlayer.Character
        task.wait(0.1)
        -- Move car to player, player in seat, car under ground
        local vehicle = humanoid.SeatPart.Parent
        local mainPart = Utils.GetVehicleMainPart(vehicle)
        if mainPart then
            mainPart.CFrame = LocalPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(0, -1000, 0)
        end
        tool.Parent = LocalPlayer.Backpack
    end
end
function ExploitModule.KillAllServer()
    local hrp = Utils.GetRootPart()
    if not hrp then return end
    local front = hrp.CFrame * CFrame.new(0, 0, -5)
    for _, player in ipairs(Services.Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local pChar = player.Character
            if pChar then
                local pHead = pChar:FindFirstChild("Head")
                if pHead then
                    pHead.Anchored = true
                    pHead.CFrame = front * CFrame.new(math.random(-5,5), 0, math.random(-5,5))
                end
            end
        end
    end
end
-- ==========================================
-- MÓDULO VEÍCULO - SISTEMA A-CHASSIS
-- ==========================================
local VehicleModule = {}
function VehicleModule.UnlockAllVehicles()
    local count = 0
    local hrp = Utils.GetRootPart()
    if not hrp then return 0 end
    Utils.SafeCall(function()
        Utils.UpdateVehicleCache()
        for _, vehicle in ipairs(State.Vehicles.cache) do
            for _, obj in ipairs(vehicle:GetDescendants()) do
                if obj:IsA("VehicleSeat") and obj.Disabled then
                    local dist = Utils.GetDistance(hrp.Position, obj.Position)
                    if dist <= State.Vehicles.unlockRange then
                        obj.Disabled = false
                        count = count + 1
                    end
                end
            end
        end
    end)
    return count
end
function VehicleModule.SetUnlockRange(value)
    State.Vehicles.unlockRange = value
end
-- ==========================================
-- MÓDULO PORTA-MALAS - SISTEMA A-CHASSIS
-- ==========================================
local PortaMalasModule = {}
function PortaMalasModule.ClearClonedTrunk()
    local count = 0
    for _, obj in ipairs(PlayerGui:GetChildren()) do
        if obj.Name == "PortaMalasClone" or obj.Name == "InvClone" then
            obj:Destroy()
            count = count + 1
        end
    end
    return count
end
function PortaMalasModule.CloneItem(itemName, vehicleName)
    if State.PortaMalas.pulling then
        return false, "Já está clonando um item!"
    end
    State.PortaMalas.pulling = true
    local success = pcall(function()
        local vehicle = Utils.FindAChassisVehicle(vehicleName)
        if vehicle and vehicle:FindFirstChild("PortaMalas") then
            local portaMalas = vehicle.PortaMalas
            for _, old in ipairs(PlayerGui:GetChildren()) do
                if old.Name == "PortaMalasClone" or old.Name == "InvClone" then
                    old:Destroy()
                end
            end
            if portaMalas:FindFirstChild("Porta-malas") then
                local portaMalasGui = portaMalas["Porta-malas"]:Clone()
                portaMalasGui.Name = "PortaMalasClone"
                portaMalasGui.Parent = PlayerGui
                portaMalasGui.Enabled = true
            end
            if portaMalas:FindFirstChild("Inv") then
                local invFolder = portaMalas.Inv:Clone()
                invFolder.Name = "InvClone"
                invFolder.Parent = PlayerGui
            end
        end
    end)
    State.PortaMalas.pulling = false
    return success, success and "Item clonado com sucesso!" or "Falha ao clonar item"
end
function PortaMalasModule.GetVehicleData()
    Utils.UpdateVehicleCache()
    local vehicleData = {}
    local usedNames = {}
    for _, vehicle in ipairs(State.Vehicles.cache) do
        if vehicle:FindFirstChild("PortaMalas") then
            local baseName = vehicle.Name
            local uniqueName = baseName
            local count = 0
            for _, name in pairs(usedNames) do
                if name == baseName then
                    count = count + 1
                elseif name:match("^" .. baseName .. "%d+$") then
                    local num = tonumber(name:match("%d+$"))
                    if num and num > count then
                        count = num
                    end
                end
            end
            if count > 0 then
                uniqueName = baseName .. (count + 1)
            end
            table.insert(usedNames, uniqueName)
            local portaMalas = vehicle.PortaMalas
            local items = {}
            if portaMalas:FindFirstChild("Inv") then
                for _, item in ipairs(portaMalas.Inv:GetChildren()) do
                    table.insert(items, item.Name)
                end
            end
            table.insert(vehicleData, {
                name = uniqueName,
                originalName = baseName,
                items = items,
                itemCount = #items
            })
        end
    end
    State.PortaMalas.vehicleData = vehicleData
    return vehicleData
end
function PortaMalasModule.StartMonitoring(updateCallback)
    if State.PortaMalas.monitorConnection then
        PortaMalasModule.StopMonitoring()
    end
    State.PortaMalas.monitorConnection = task.spawn(function()
        while true do
            task.wait(0.5) -- Atualização a cada 0.5s para reduzir lag
            if not State.PortaMalas.isRefreshing and updateCallback then
                updateCallback()
            end
        end
    end)
end
function PortaMalasModule.StopMonitoring()
    if State.PortaMalas.monitorConnection then
        task.cancel(State.PortaMalas.monitorConnection)
        State.PortaMalas.monitorConnection = nil
    end
end
-- ==========================================
-- MÓDULO COMBATE
-- ==========================================
local CombatModule = {}
-- Integração da lógica de Silent Aim baseada em raycast simples, sem hooks
-- Lógica do Silent Aim (sem UI e drawings extras, apenas lógica principal)
local SilentAimSettings = {
    Enabled = false,
    TeamCheck = false,
    VisibleCheck = false,
    TargetPart = "Head",
    SilentAimMethod = "Raycast",
    FOV = 90, -- Será atualizado com SilentFOVWidth / 2
    MouseHitPrediction = false,
    MouseHitPredictionAmount = 0.165,
    HitChance = 100
}
getgenv().SilentAimSettings = SilentAimSettings
local Camera = workspace.CurrentCamera
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local WorldToViewportPoint = Camera.WorldToViewportPoint
local GetMouseLocation = UserInputService.GetMouseLocation
local ExpectedArguments = {
    Raycast = {
        ArgCountRequired = 3,
        Args = {
            "Instance", "Vector3", "Vector3", "RaycastParams"
        }
    }
}
local function CalculateChance(Percentage)
    Percentage = math.floor(Percentage)
    local chance = math.floor(math.random(1, 100))
    return chance <= Percentage
end
function getPositionOnScreen(Vector)
    local Vec3, OnScreen = WorldToViewportPoint(Camera, Vector)
    return Vector2.new(Vec3.X, Vec3.Y), OnScreen
end
function ValidateArguments(Args, RayMethod)
    local Matches = 0
    if #Args < RayMethod.ArgCountRequired then
        return false
    end
    for Pos, Argument in next, Args do
        if typeof(Argument) == RayMethod.Args[Pos] then
            Matches = Matches + 1
        end
    end
    return Matches >= RayMethod.ArgCountRequired
end
function getDirection(Origin, Position)
    return (Position - Origin).Unit * 1000
end
function getMousePosition()
    return GetMouseLocation(UserInputService)
end
function IsPlayerVisible(Player)
    local PlayerCharacter = Player.Character
    local LocalPlayerCharacter = LocalPlayer.Character
    if not (PlayerCharacter or LocalPlayerCharacter) then return end
    local PlayerRoot = PlayerCharacter:FindFirstChild(SilentAimSettings.TargetPart) or PlayerCharacter:FindFirstChild("HumanoidRootPart")
    if not PlayerRoot then return end
    local CastPoints, IgnoreList = {PlayerRoot.Position, LocalPlayerCharacter, PlayerCharacter}, {LocalPlayerCharacter, PlayerCharacter}
    local ObscuringObjects = #Camera:GetPartsObscuringTarget(CastPoints, IgnoreList)
    return ((ObscuringObjects == 0 and true) or (ObscuringObjects > 0 and false))
end
function getClosestPlayer()
    local Closest
    local DistanceToMouse
    for _, Player in next, Players:GetPlayers() do
        if Player == LocalPlayer then continue end
        if SilentAimSettings.TeamCheck and Player.Team == LocalPlayer.Team then continue end
        local Character = Player.Character
        if not Character then continue end
        if SilentAimSettings.VisibleCheck and not IsPlayerVisible(Player) then continue end
        local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
        local Humanoid = Character:FindFirstChild("Humanoid")
        if not HumanoidRootPart or not Humanoid or Humanoid.Health <= 0 then continue end
        local ScreenPosition, OnScreen = getPositionOnScreen(HumanoidRootPart.Position)
        if not OnScreen then continue end
        local Distance = (getMousePosition() - ScreenPosition).Magnitude
        if Distance <= (DistanceToMouse or SilentAimSettings.FOV or 200) then
            Closest = ((SilentAimSettings.TargetPart == "Random" and Character[ValidTargetParts[math.random(1, #ValidTargetParts)]]) or Character[SilentAimSettings.TargetPart])
            DistanceToMouse = Distance
        end
    end
    return Closest
end
-- Fim da lógica de Silent Aim
-- Atualização das configurações do Silent Aim a partir do DN Menu
function CombatModule.UpdateAimbotSettings()
    if getgenv().DNMenuAimbot then
        local ab = getgenv().DNMenuAimbot
        ab.Enabled = State.Features.Aimbot.Enabled
        ab.ShowFOV = State.Features.Aimbot.ShowFOV
        ab.FOVWidth = State.Features.Aimbot.FOVWidth
        ab.FOVHeight = State.Features.Aimbot.FOVHeight
        ab.FOVThickness = State.Features.Aimbot.FOVThickness
        ab.FOVColor = State.Features.Aimbot.FOVColor
        ab.SilentEnabled = State.Features.Aimbot.SilentEnabled
        ab.SilentFOVWidth = State.Features.Aimbot.SilentFOVWidth
        ab.SilentFOVHeight = State.Features.Aimbot.SilentFOVHeight
        ab.SilentFOVThickness = State.Features.Aimbot.SilentFOVThickness
        ab.SilentFOVColor = State.Features.Aimbot.SilentFOVColor
        ab.MaxDistance = State.Features.Aimbot.MaxDistance
        ab.WallCheck = State.Features.Aimbot.WallCheck
        ab.Smoothness = State.Features.Aimbot.Smoothness
        ab.Friends = State.Friends
    end
    -- Atualizar SilentAimSettings do logic integrado
    SilentAimSettings.Enabled = State.Features.Aimbot.SilentEnabled
    SilentAimSettings.VisibleCheck = State.Features.Aimbot.WallCheck
    SilentAimSettings.FOV = math.min(State.Features.Aimbot.SilentFOVWidth, State.Features.Aimbot.SilentFOVHeight) / 2
    SilentAimSettings.TargetPart = "Head"
    SilentAimSettings.TeamCheck = false -- Sem team check no DN
    SilentAimSettings.SilentAimMethod = "Raycast"
    SilentAimSettings.HitChance = 100 -- Fixo, sem slider no DN
    SilentAimSettings.MouseHitPrediction = false -- Sem setting no DN
end
function CombatModule.LoadAimbot()
    if getgenv().DNMenuAimbot then
        return true
    end
    local success = Utils.SafeCall(function()
        local code = [[
local Camera = workspace.CurrentCamera
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local Friends = getgenv().DNMenuFriends or {}
local Aimbot = {
    Enabled = false,
    ShowFOV = true,
    FOVWidth = 180,
    FOVHeight = 180,
    FOVThickness = 2,
    FOVColor = Color3.fromRGB(138, 43, 226),
    SilentEnabled = false,
    SilentFOVWidth = 180,
    SilentFOVHeight = 180,
    SilentFOVThickness = 2,
    SilentFOVColor = Color3.fromRGB(255, 0, 0),
    MaxDistance = 500,
    WallCheck = false,
    Smoothness = 0.2,
    FOVBox = Drawing.new("Square"),
    SilentFOVBox = Drawing.new("Square"),
    Locked = nil,
    IsMobile = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled,
    Friends = Friends
}
Aimbot.FOVBox.Thickness = Aimbot.FOVThickness
Aimbot.FOVBox.Filled = false
Aimbot.FOVBox.Color = Aimbot.FOVColor
Aimbot.FOVBox.Transparency = 1
Aimbot.FOVBox.Visible = false
Aimbot.SilentFOVBox.Thickness = Aimbot.SilentFOVThickness
Aimbot.SilentFOVBox.Filled = false
Aimbot.SilentFOVBox.Color = Aimbot.SilentFOVColor
Aimbot.SilentFOVBox.Transparency = 1
Aimbot.SilentFOVBox.Visible = false
local function GetClosest(fovWidth, fovHeight)
    local closestPlayer = nil
    local shortestDistance = math.huge
    local mousePos = Aimbot.IsMobile and Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2) or UserInputService:GetMouseLocation()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and not table.find(Aimbot.Friends, player.Name) and player.Character then
            local humanoid = player.Character:FindFirstChild("Humanoid")
            local head = player.Character:FindFirstChild("Head")
            if humanoid and humanoid.Health > 0 and head then
                local screenPos, onScreen = Camera:WorldToViewportPoint(head.Position)
                if onScreen then
                    local dx = screenPos.X - mousePos.X
                    local dy = screenPos.Y - mousePos.Y
                    local halfW = fovWidth / 2
                    local halfH = fovHeight / 2
                    local dist = math.sqrt((dx / halfW)^2 + (dy / halfH)^2)
                    if dist < 1 and dist < shortestDistance then
                        local distanceToPlayer = (head.Position - Camera.CFrame.Position).Magnitude
                        if distanceToPlayer <= Aimbot.MaxDistance then
                            if not Aimbot.WallCheck or (Aimbot.WallCheck and workspace:FindPartOnRayWithIgnoreList(
                                Ray.new(Camera.CFrame.Position, (head.Position - Camera.CFrame.Position).Unit * distanceToPlayer),
                                {LocalPlayer.Character, Camera}
                            ) == nil or workspace:FindPartOnRayWithIgnoreList(...):IsDescendantOf(player.Character)) then
                                closestPlayer = player
                                shortestDistance = dist
                            end
                        end
                    end
                end
            end
        end
    end
    return closestPlayer
end
local function GetClosestSilent()
    return GetClosest(Aimbot.SilentFOVWidth, Aimbot.SilentFOVHeight)
end
local isAiming = false
if Aimbot.IsMobile then
    UserInputService.TouchStarted:Connect(function(_, gp) if not gp then isAiming = true end end)
    UserInputService.TouchEnded:Connect(function() isAiming = false end)
else
    UserInputService.InputBegan:Connect(function(input, gp)
        if input.UserInputType == Enum.UserInputType.MouseButton2 and Aimbot.Enabled and not gp then
            isAiming = true
        end
    end)
    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton2 then
            isAiming = false
        end
    end)
end
RunService.RenderStepped:Connect(function()
    local mousePos = Aimbot.IsMobile and Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2) or UserInputService:GetMouseLocation()
    Aimbot.FOVBox.Size = Vector2.new(Aimbot.FOVWidth, Aimbot.FOVHeight)
    Aimbot.FOVBox.Position = mousePos - Vector2.new(Aimbot.FOVWidth/2, Aimbot.FOVHeight/2)
    Aimbot.FOVBox.Color = Aimbot.FOVColor
    Aimbot.FOVBox.Thickness = Aimbot.FOVThickness
    Aimbot.FOVBox.Visible = Aimbot.Enabled and Aimbot.ShowFOV
    Aimbot.SilentFOVBox.Size = Vector2.new(Aimbot.SilentFOVWidth, Aimbot.SilentFOVHeight)
    Aimbot.SilentFOVBox.Position = mousePos - Vector2.new(Aimbot.SilentFOVWidth/2, Aimbot.SilentFOVHeight/2)
    Aimbot.SilentFOVBox.Color = Aimbot.SilentFOVColor
    Aimbot.SilentFOVBox.Thickness = Aimbot.SilentFOVThickness
    Aimbot.SilentFOVBox.Visible = Aimbot.Enabled and Aimbot.SilentEnabled
    if Aimbot.Enabled and isAiming then
        local target = GetClosest(Aimbot.FOVWidth, Aimbot.FOVHeight)
        if target and target.Character and target.Character:FindFirstChild("Head") then
            local head = target.Character.Head
            Camera.CFrame = Camera.CFrame:Lerp(CFrame.new(Camera.CFrame.Position, head.Position), Aimbot.Smoothness)
        end
    end
    if Aimbot.SilentEnabled then
        local silentTarget = GetClosestSilent()
        if silentTarget and silentTarget.Character and silentTarget.Character:FindFirstChild("Head") then
            getgenv().silentTarget = silentTarget.Character.Head.Position
        else
            getgenv().silentTarget = nil
        end
    end
end)
getgenv().DNMenuAimbot = Aimbot
]]
        loadstring(code)()
    end)
    return success
end
function CombatModule.ActivateHitboxExpander(enabled)
    local feature = State.Features.HitboxExpander
    feature.active = enabled
    if enabled then
        for _, player in ipairs(Services.Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local hrp = player.Character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    feature.originalSizes[player.UserId] = hrp.Size
                    hrp.Size = Vector3.new(feature.size, feature.size, feature.size)
                    hrp.Transparency = feature.transparency
                    hrp.CanCollide = false
                end
            end
        end
        Services.Players.PlayerAdded:Connect(function(player)
            if feature.active then
                player.CharacterAdded:Connect(function(char)
                    task.wait(0.5)
                    local hrp = char:FindFirstChild("HumanoidRootPart")
                    if hrp and feature.active then
                        feature.originalSizes[player.UserId] = hrp.Size
                        hrp.Size = Vector3.new(feature.size, feature.size, feature.size)
                        hrp.Transparency = feature.transparency
                        hrp.CanCollide = false
                    end
                end)
            end
        end)
    else
        for _, player in ipairs(Services.Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local hrp = player.Character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    local originalSize = feature.originalSizes[player.UserId] or Vector3.new(2, 2, 1)
                    hrp.Size = originalSize
                    hrp.Transparency = 1
                    hrp.CanCollide = false
                end
            end
        end
        feature.originalSizes = {}
    end
end
function CombatModule.SetHitboxSize(size)
    State.Features.HitboxExpander.size = size
    if State.Features.HitboxExpander.active then
        for _, player in ipairs(Services.Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local hrp = player.Character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    hrp.Size = Vector3.new(size, size, size)
                end
            end
        end
    end
end
function CombatModule.SetHitboxTransparency(trans)
    State.Features.HitboxExpander.transparency = trans
    if State.Features.HitboxExpander.active then
        for _, player in ipairs(Services.Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local hrp = player.Character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    hrp.Transparency = trans
                end
            end
        end
    end
end
-- ==========================================
-- MÓDULO LISTA DE JOGADORES
-- ==========================================
local PlayerListModule = {}
function PlayerListModule.UpdatePlayerList()
    State.Players.list = {}
    for _, player in ipairs(Services.Players:GetPlayers()) do
        table.insert(State.Players.list, player.Name)
    end
    return State.Players.list
end
function PlayerListModule.SelectPlayer(playerName)
    State.Players.selected = Services.Players:FindFirstChild(playerName)
    State.Features.BangPlayer.target = State.Players.selected
end
function PlayerListModule.TeleportToPlayer()
    if not State.Players.selected or not State.Players.selected.Character then
        return
    end
    local hrp = Utils.GetRootPart()
    local targetHRP = Utils.GetRootPart(State.Players.selected)
    if hrp and targetHRP then
        hrp.CFrame = targetHRP.CFrame
    end
end
-- ==========================================
-- MÓDULO DE AUTENTICAÇÃO
-- ==========================================
local AuthModule = {}
function AuthModule.CheckAuth()
    local success, response = pcall(function()
        return game:HttpGet(Config.AllowedUsersURL)
    end)
    if not success then
        return false
    end
    local allowed = {}
    for line in response:gmatch("[^\r\n]+") do
        local trimmed = line:match("^%s*(.-)%s*$")
        if trimmed ~= "" and not trimmed:match("^#") then
            allowed[trimmed] = true
        end
    end
    return allowed[LocalPlayer.Name] or false
end
function AuthModule.StartAuthVerification()
    if State.Auth.verificationConnection then return end
    State.Auth.verificationConnection = task.spawn(function()
        while true do
            task.wait(State.Auth.checkInterval)
            local currentTime = tick()
            if currentTime - State.Auth.lastCheck < State.Auth.checkInterval then
                continue
            end
            State.Auth.lastCheck = currentTime
            if not AuthModule.CheckAuth() then
                LocalPlayer:Kick("Sua sessão expirou 😿. Adquira uma nova licença para o DN Menu e volte a ter a melhor experiência novamente conosco!")
            end
        end
    end)
end
function AuthModule.StopAuthVerification()
    if State.Auth.verificationConnection then
        task.cancel(State.Auth.verificationConnection)
        State.Auth.verificationConnection = nil
    end
end
-- ==========================================
-- CLEANUP COMPLETO
-- ==========================================
local function PerformCleanup()
    if State.Features.Exorcismo.active then
        ExploitModule.ActivateExorcismo(false)
        task.wait(0.3)
    end
    VisualModule.ActivateESP(false)
    VisualModule.ActivateESPSkeleton(false)
    VisualModule.ActivateChams(false)
    VisualModule.ActivateFullbright(false)
    ExploitModule.ActivateGunPull(false)
    ExploitModule.ActivateBangPlayer(false)
    ExploitModule.ActivateVehicleLauncher(false)
    ExploitModule.ActivateAutoUnlock(false)
    ExploitModule.ActivateVehicleDelete(false)
    ExploitModule.ActivateVehicleFly(false)
    ExploitModule.ActivateVehicleNoclip(false)
    CombatModule.ActivateHitboxExpander(false)
    PlayerModule.ActivateNoclip(false)
    -- Removida lógica do SoloSession
    for _, feature in pairs(State.Features) do
        if feature.connection then
            Utils.ClearConnections({feature.connection})
        end
        if feature.connections then
            Utils.ClearConnections(feature.connections)
        end
    end
    PortaMalasModule.StopMonitoring()
    if getgenv().DNMenuAimbot then
        State.Features.Aimbot.Enabled = false
        CombatModule.UpdateAimbotSettings()
        if getgenv().DNMenuAimbot.FOVBox then
            getgenv().DNMenuAimbot.FOVBox:Remove()
        end
        if getgenv().DNMenuAimbot.SilentFOVBox then
            getgenv().DNMenuAimbot.SilentFOVBox:Remove()
        end
        getgenv().DNMenuAimbot = nil
    end
    PortaMalasModule.ClearClonedTrunk()
    if State.Features.Chams.folder then
        State.Features.Chams.folder:Destroy()
    end
    for _, billboard in pairs(State.Features.ESP.billboards) do
        if billboard then billboard:Destroy() end
    end
    State.Features.ESP.billboards = {}
    if State.Features.Fullbright.active then
        VisualModule.ActivateFullbright(false)
    end
    -- Adições para restaurar tudo
    PlayerModule.SetCameraFOV(Config.Defaults.CameraFOV)
    State.Features.Speed.value = Config.Defaults.Speed
    State.Vehicles.unlockRange = Config.Defaults.VehicleRange
    State.Features.ESP.color = Color3.fromRGB(138, 43, 226)
    State.Features.ESPSkeleton.color = Color3.fromRGB(138, 43, 226)
    State.Features.ESPAdmin.adminColor = Color3.fromRGB(255, 0, 0)
    State.Features.Chams.fillColor = Color3.fromRGB(138, 43, 226)
    State.Features.Chams.outlineColor = Color3.fromRGB(75, 0, 130)
    State.Features.Aimbot.FOVColor = Color3.fromRGB(138, 43, 226)
    State.Features.Aimbot.SilentFOVColor = Color3.fromRGB(255, 0, 0)
end
local function SetupAutoCleanup(Window)
    LocalPlayer.AncestryChanged:Connect(function()
        PerformCleanup()
        AuthModule.StopAuthVerification()
    end)
end
local function BypassTelagem(WindUI)
    PerformCleanup()
    for _, feature in pairs(State.Features) do
        if feature.toggle and feature.toggle.Set then
            pcall(function()
                feature.toggle:Set(false)
            end)
        end
    end
    WindUI:Notify({
        Title = "Bypass Telagem",
        Content = "Todas as funcionalidades foram desativadas",
        Icon = "power",
        Duration = 3
    })
end
local function SetupToggleVisibility(Window)
    Services.UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.KeyCode == Enum.KeyCode.F3 then
            Window:Toggle()
        end
    end)
    if Utils.IsMobile() then
        local lastTapTime = 0
        local tapCount = 0
        Services.UserInputService.TouchStarted:Connect(function(touch, gameProcessed)
            if gameProcessed then return end
            local touches = Services.UserInputService:GetTouches()
            if #touches >= 3 then
                local currentTime = tick()
                if currentTime - lastTapTime < 0.5 then
                    tapCount = tapCount + 1
                    if tapCount >= 2 then
                        Window:Toggle()
                        tapCount = 0
                    end
                else
                    tapCount = 1
                end
                lastTapTime = currentTime
            end
        end)
    end
end
-- ==========================================
-- INTERFACE - ADICIONAR ELEMENTOS
-- ==========================================
local function AddMenuElements(Window, WindUI)
    local PlayerTab = Window:Tab({
        Title = "Jogador",
        Icon = "user",
        IconColor = Color3.fromRGB(138, 43, 226),
    })
    local PlayerSection = PlayerTab:Section({
        Title = "Configurações",
    })
    local PlayerColorsSection = PlayerTab:Section({
        Title = "Cores",
    })
    State.Features.Speed.toggle = PlayerSection:Toggle({
        Title = "Speed Hack",
        Desc = "Aumenta a velocidade de movimento",
        Locked = true,
        Icon = "check",
        Type = "Checkbox",
        Callback = function(value)
            PlayerModule.ActivateSpeed(value)
        end
    })
    PlayerSection:Slider({
        Title = "Velocidade",
        Desc = "Ajuste a velocidade (padrão: 16)",
        Locked = true,
        Step = 1,
        Value = {
            Min = 16,
            Max = 200,
            Default = Config.Defaults.Speed,
        },
        Callback = function(value)
            PlayerModule.SetSpeed(value)
        end
    })
    PlayerSection:Slider({
        Title = "Camera FOV",
        Desc = "Ajuste o campo de visão da câmera (padrão: 70)",
        Step = 1,
        Value = {
            Min = 1,
            Max = 100,
            Default = Config.Defaults.CameraFOV,
        },
        Callback = function(value)
            PlayerModule.SetCameraFOV(value)
        end
    })
    State.Features.Godmode.toggle = PlayerSection:Toggle({
        Title = "Invulnerabilidade",
        Desc = "Seu personagem não perde vida",
        Locked = true,
        Icon = "check",
        Type = "Checkbox",
        Callback = function(value)
            PlayerModule.ActivateGodmode(value)
        end
    })
    State.Features.Noclip.toggle = PlayerSection:Toggle({
        Title = "Atravessar Paredes (Noclip)",
        Desc = "Permite atravessar paredes",
        Icon = "check",
        Type = "Checkbox",
        Callback = function(value)
            PlayerModule.ActivateNoclip(value)
        end
    })
    State.Features.SoloSession.toggle = PlayerSection:Toggle({
        Title = "Invisible Solo Session",
        Desc = "Fica invisível e deslocado",
        Locked = true,
        Icon = "check",
        Type = "Checkbox",
        Callback = function(value)
            PlayerModule.ActivateSoloSession(value)
        end
    })
    local VisualTab = Window:Tab({
        Title = "Visuais",
        Icon = "eye",
        IconColor = Color3.fromRGB(138, 43, 226),
    })
    local EspSection = VisualTab:Section({
        Title = "ESP",
    })
    local VisualColorsSection = VisualTab:Section({
        Title = "Cores",
    })
    State.Features.ESP.toggle = EspSection:Toggle({
        Title = "ESP Jogadores",
        Desc = "Mostra nome e distância através de paredes",
        Icon = "check",
        Type = "Checkbox",
        Callback = function(value)
            VisualModule.ActivateESP(value)
        end
    })
    State.Features.ESPSkeleton.toggle = EspSection:Toggle({
        Title = "ESP Skeleton",
        Desc = "Mostra esqueleto dos jogadores",
        Icon = "check",
        Type = "Checkbox",
        Callback = function(value)
            VisualModule.ActivateESPSkeleton(value)
        end
    })
    State.Features.ESPRGB.toggle = EspSection:Toggle({
        Title = "ESP RGB",
        Desc = "Cor do ESP muda em RGB",
        Locked = true,
        Icon = "check",
        Type = "Checkbox",
        Callback = function(value)
            VisualModule.ActivateESPRGB(value)
        end
    })
    State.Features.ESPAdmin.toggle = EspSection:Toggle({
        Title = "ESP Admins",
        Desc = "Cor especial para admins (voando/invisível)",
        Icon = "check",
        Type = "Checkbox",
        Callback = function(value)
            VisualModule.ActivateESPAdmin(value)
        end
    })
    State.Features.Chams.toggle = EspSection:Toggle({
        Title = "Chams",
        Desc = "Destaca jogadores com contorno colorido",
        Icon = "check",
        Type = "Checkbox",
        Callback = function(value)
            VisualModule.ActivateChams(value)
        end
    })
    State.Features.Fullbright.toggle = EspSection:Toggle({
        Title = "Fullbright",
        Desc = "Iluminação máxima no mapa",
        Icon = "check",
        Type = "Checkbox",
        Callback = function(value)
            VisualModule.ActivateFullbright(value)
        end
    })
    VisualColorsSection:Colorpicker({
        Title = "Cor do ESP",
        Desc = "Personalize a cor do texto do ESP",
        Default = State.Features.ESP.color,
        Callback = function(value)
            State.Features.ESP.color = value
            VisualModule.UpdateESPColor(value)
        end
    })
    VisualColorsSection:Colorpicker({
        Title = "Cor Admin ESP",
        Desc = "Cor para admins detectados",
        Default = State.Features.ESPAdmin.adminColor,
        Callback = function(value)
            State.Features.ESPAdmin.adminColor = value
        end
    })
    VisualColorsSection:Colorpicker({
        Title = "Cor do Preenchimento Chams",
        Desc = "Cor interna do highlight",
        Default = State.Features.Chams.fillColor,
        Callback = function(value)
            State.Features.Chams.fillColor = value
            VisualModule.UpdateChamsColors()
        end
    })
    VisualColorsSection:Colorpicker({
        Title = "Cor do Contorno Chams",
        Desc = "Cor da borda do highlight",
        Default = State.Features.Chams.outlineColor,
        Callback = function(value)
            State.Features.Chams.outlineColor = value
            VisualModule.UpdateChamsColors()
        end
    })
    local ExploitTab = Window:Tab({
        Title = "Exploits",
        Icon = "zap",
        IconColor = Color3.fromRGB(138, 43, 226),
    })
    local ExploitSection = ExploitTab:Section({
        Title = "Configurações",
    })
    local ExploitColorsSection = ExploitTab:Section({
        Title = "Cores",
    })
    local PlayerSpecificSection = ExploitTab:Section({
        Title = "Ações de Jogador",
    })
    local playerList = PlayerListModule.UpdatePlayerList()
    local PlayerDropdownExploit = PlayerSpecificSection:Dropdown({
        Title = "Selecionar Jogador",
        Desc = "Escolha um jogador",
        Values = playerList,
        Value = playerList[1] or "Nenhum",
        Callback = function(value)
            PlayerListModule.SelectPlayer(value)
        end
    })
    PlayerSpecificSection:Button({
        Title = "Atualizar Lista",
        Desc = "Recarrega a lista de jogadores",
        Callback = function()
            local updatedList = PlayerListModule.UpdatePlayerList()
            PlayerDropdownExploit:Refresh(updatedList)
            WindUI:Notify({
                Title = "Lista Atualizada",
                Content = #updatedList .. " jogador(es) encontrado(s)",
                Icon = "refresh-cw"
            })
        end
    })
    PlayerSpecificSection:Button({
        Title = "Adicionar Amigo",
        Desc = "Adiciona o jogador selecionado como amigo (ignora aimbot)",
        Callback = function()
            if State.Players.selected then
                ExploitModule.AddFriend(State.Players.selected.Name)
                WindUI:Notify({
                    Title = "Amigo Adicionado",
                    Content = State.Players.selected.Name .. " adicionado aos amigos",
                    Icon = "user-plus"
                })
            end
        end
    })
    PlayerSpecificSection:Button({
        Title = "Remover Amigo",
        Desc = "Remove o jogador selecionado dos amigos",
        Callback = function()
            if State.Players.selected then
                ExploitModule.RemoveFriend(State.Players.selected.Name)
                WindUI:Notify({
                    Title = "Amigo Removido",
                    Content = State.Players.selected.Name .. " removido dos amigos",
                    Icon = "user-minus"
                })
            end
        end
    })
    State.Features.BangPlayer.toggle = PlayerSpecificSection:Toggle({
        Title = "Grudar no Jogador",
        Desc = "Gruda atrás do jogador selecionado",
        Icon = "check",
        Type = "Checkbox",
        Callback = function(value)
            if value and not State.Players.selected then
                WindUI:Notify({
                    Title = "Erro",
                    Content = "Selecione um jogador primeiro",
                    Icon = "x"
                })
                State.Features.BangPlayer.toggle:Set(false)
                return
            end
            ExploitModule.ActivateBangPlayer(value)
        end
    })
    PlayerSpecificSection:Button({
        Title = "Teleportar para Jogador",
        Desc = "Teleporta até o jogador selecionado",
        Callback = function()
            if not State.Players.selected then
                WindUI:Notify({
                    Title = "Erro",
                    Content = "Selecione um jogador primeiro",
                    Icon = "x"
                })
                return
            end
            PlayerListModule.TeleportToPlayer()
            WindUI:Notify({
                Title = "Teleporte",
                Content = "Teleportado para " .. State.Players.selected.Name,
                Icon = "zap"
            })
        end
    })
    PlayerSpecificSection:Button({
        Title = "Spectate Jogador",
        Desc = "Observa o jogador selecionado",
        Callback = function()
            if State.Players.selected and State.Players.selected.Character then
                Services.Workspace.CurrentCamera.CameraSubject = State.Players.selected.Character
                WindUI:Notify({
                    Title = "Spectate",
                    Content = "Observando " .. State.Players.selected.Name,
                    Icon = "eye"
                })
            else
                WindUI:Notify({
                    Title = "Erro",
                    Content = "Jogador inválido",
                    Icon = "x"
                })
            end
        end
    })
    PlayerSpecificSection:Button({
        Title = "Parar Spectate",
        Desc = "Retorna a câmera",
        Callback = function()
            Services.Workspace.CurrentCamera.CameraSubject = Utils.GetHumanoid()
            WindUI:Notify({
                Title = "Spectate",
                Content = "Câmera restaurada",
                Icon = "eye-off"
            })
        end
    })
    local GeneralExploitsSection = ExploitTab:Section({
        Title = "Exploits Gerais",
    })
    State.Features.GunPull.toggle = GeneralExploitsSection:Toggle({
        Title = "Puxar Armas",
        Desc = "Puxa armas de outros jogadores",
        Icon = "check",
        Type = "Checkbox",
        Callback = function(value)
            ExploitModule.ActivateGunPull(value)
        end
    })
    State.Features.Exorcismo.toggle = GeneralExploitsSection:Toggle({
        Title = "Exorcismo",
        Desc = "Ativa animações customizadas",
        Icon = "check",
        Type = "Checkbox",
        Callback = function(value)
            ExploitModule.ActivateExorcismo(value)
        end
    })
    State.Features.VehicleLauncher.toggle = GeneralExploitsSection:Toggle({
        Title = "Lançar Veículos A-Chassis",
        Desc = "Clique: Segurar | Y: Lançar",
        Icon = "check",
        Type = "Checkbox",
        Callback = function(value)
            ExploitModule.ActivateVehicleLauncher(value)
            if value then
                WindUI:Notify({
                    Title = "Lançador Ativado",
                    Content = "Detecta automaticamente veículos A-Chassis\nClique: Segurar | Y: Lançar",
                    Icon = "car-front",
                    Duration = 5
                })
            end
        end
    })
    GeneralExploitsSection:Button({
        Title = "Limpar Players com Veículo",
        Desc = "Remove o jogador selecionado do veículo (sem telecinese)",
        Callback = function()
            ExploitModule.CleanPlayersWithVehicle()
            WindUI:Notify({
                Title = "Limpar Players",
                Content = "Função executada",
                Icon = "trash-2"
            })
        end
    })
    GeneralExploitsSection:Button({
        Title = "Matar Todos do Servidor",
        Desc = "Coloca cabeças na frente para matar",
        Callback = function()
            ExploitModule.KillAllServer()
            WindUI:Notify({
                Title = "Matar Todos",
                Content = "Cabeças posicionadas, pegue arma e atire",
                Icon = "skull"
            })
        end
    })
    Services.Players.PlayerAdded:Connect(function()
        local updatedList = PlayerListModule.UpdatePlayerList()
        if PlayerDropdownExploit then
            PlayerDropdownExploit:Refresh(updatedList)
        end
    end)
    Services.Players.PlayerRemoving:Connect(function()
        local updatedList = PlayerListModule.UpdatePlayerList()
        if PlayerDropdownExploit then
            PlayerDropdownExploit:Refresh(updatedList)
        end
    end)
    local DestructionTab = Window:Tab({
        Title = "Destruição",
        Icon = "bomb",
        IconColor = Color3.fromRGB(138, 43, 226),
    })
    local DestructionSection = DestructionTab:Section({
        Title = "Configurações",
    })
    local DestructionColorsSection = DestructionTab:Section({
        Title = "Cores",
    })
    DestructionSection:Button({
        Title = "Ativar Telecinese",
        Desc = "Carrega script de telecinese",
        Callback = function()
            if not loadstring then
                WindUI:Notify({
                    Title = "Erro",
                    Content = "loadstring não disponível",
                    Icon = "x"
                })
                return
            end
            Utils.SafeCall(function()
                loadstring(game:HttpGet(Config.externos.Telekinesis))()
            end)
        end
    })
    local CombatTab = Window:Tab({
        Title = "Combate",
        Icon = "hand-fist",
        IconColor = Color3.fromRGB(138, 43, 226),
    })
    local AimbotSection = CombatTab:Section({
        Title = "Aimbot",
    })
    local AimbotColorsSection = CombatTab:Section({
        Title = "Cores Aimbot",
    })
    local HitboxSection = CombatTab:Section({
        Title = "Hitbox Expander",
    })
    local HitboxColorsSection = CombatTab:Section({
        Title = "Cores Hitbox",
    })
    AimbotSection:Button({
        Title = "Carregar Aimbot",
        Desc = "Inicializa o sistema de mira",
        Callback = function()
            getgenv().DNMenuFriends = State.Friends
            local success = CombatModule.LoadAimbot()
            WindUI:Notify({
                Title = success and "Sucesso" or "Erro",
                Content = success and "Aimbot carregado!" or "Falha ao carregar",
                Icon = success and "check" or "x"
            })
        end
    })
        State.Features.Aimbot.toggle = AimbotSection:Toggle({
        Title = "Ativar Aimbot",
        Desc = "Liga/desliga a mira automática",
        Icon = "check",
        Type = "Checkbox",
        Callback = function(value)
            State.Features.Aimbot.Enabled = value
            CombatModule.UpdateAimbotSettings()
        end
    })
    AimbotSection:Toggle({
        Title = "Mostrar FOV",
        Desc = "Mostra/oculta o quadrado FOV",
        Default = true,
        Icon = "check",
        Type = "Checkbox",
        Callback = function(value)
            State.Features.Aimbot.ShowFOV = value
            CombatModule.UpdateAimbotSettings()
        end
    })
    AimbotSection:Slider({
        Title = "Largura FOV",
        Desc = "Largura do FOV",
        Step = 5,
        Value = {
            Min = 30,
            Max = 500,
            Default = 180,
        },
        Callback = function(value)
            State.Features.Aimbot.FOVWidth = value
            CombatModule.UpdateAimbotSettings()
        end
    })
    AimbotSection:Slider({
        Title = "Altura FOV",
        Desc = "Altura do FOV",
        Step = 5,
        Value = {
            Min = 30,
            Max = 500,
            Default = 180,
        },
        Callback = function(value)
            State.Features.Aimbot.FOVHeight = value
            CombatModule.UpdateAimbotSettings()
        end
    })
    AimbotSection:Slider({
        Title = "Espessura FOV",
        Desc = "Espessura da linha FOV",
        Step = 1,
        Value = {
            Min = 1,
            Max = 5,
            Default = 2,
        },
        Callback = function(value)
            State.Features.Aimbot.FOVThickness = value
            CombatModule.UpdateAimbotSettings()
        end
    })
    AimbotColorsSection:Colorpicker({
        Title = "Cor do FOV",
        Desc = "Cor do quadrado FOV",
        Default = State.Features.Aimbot.FOVColor,
        Callback = function(value)
            State.Features.Aimbot.FOVColor = value
            CombatModule.UpdateAimbotSettings()
        end
    })
    AimbotSection:Toggle({
        Title = "Silent Aim",
        Desc = "Ativa silent aim",
        Icon = "check",
        Type = "Checkbox",
        Callback = function(value)
            State.Features.Aimbot.SilentEnabled = value
            CombatModule.UpdateAimbotSettings()
        end
    })
    AimbotSection:Slider({
        Title = "Largura Silent FOV",
        Desc = "Largura do silent FOV",
        Step = 5,
        Value = {
            Min = 30,
            Max = 500,
            Default = 180,
        },
        Callback = function(value)
            State.Features.Aimbot.SilentFOVWidth = value
            CombatModule.UpdateAimbotSettings()
        end
    })
    AimbotSection:Slider({
        Title = "Altura Silent FOV",
        Desc = "Altura do silent FOV",
        Step = 5,
        Value = {
            Min = 30,
            Max = 500,
            Default = 180,
        },
        Callback = function(value)
            State.Features.Aimbot.SilentFOVHeight = value
            CombatModule.UpdateAimbotSettings()
        end
    })
    AimbotSection:Slider({
        Title = "Espessura Silent FOV",
        Desc = "Espessura da linha silent FOV",
        Step = 1,
        Value = {
            Min = 1,
            Max = 5,
            Default = 2,
        },
        Callback = function(value)
            State.Features.Aimbot.SilentFOVThickness = value
            CombatModule.UpdateAimbotSettings()
        end
    })
    AimbotColorsSection:Colorpicker({
        Title = "Cor Silent FOV",
        Desc = "Cor do silent FOV",
        Default = State.Features.Aimbot.SilentFOVColor,
        Callback = function(value)
            State.Features.Aimbot.SilentFOVColor = value
            CombatModule.UpdateAimbotSettings()
        end
    })
    AimbotSection:Slider({
        Title = "Distância Máxima",
        Desc = "Alcance máximo em studs",
        Step = 50,
        Value = {
            Min = 100,
            Max = 2000,
            Default = 500,
        },
        Callback = function(value)
            State.Features.Aimbot.MaxDistance = value
            CombatModule.UpdateAimbotSettings()
        end
    })
    AimbotSection:Slider({
        Title = "Suavidade",
        Desc = "Velocidade da mira (0 = rápido, 1 = lento)",
        Step = 0.05,
        Value = {
            Min = 0,
            Max = 1,
            Default = 0.2,
        },
        Callback = function(value)
            State.Features.Aimbot.Smoothness = value
            CombatModule.UpdateAimbotSettings()
        end
    })
    AimbotSection:Toggle({
        Title = "Mirar Através de Paredes",
        Desc = "Permite mirar através de obstáculos",
        Default = false,
        Icon = "check",
        Type = "Checkbox",
        Callback = function(value)
            State.Features.Aimbot.WallCheck = not value
            CombatModule.UpdateAimbotSettings()
        end
    })
    State.Features.HitboxExpander.toggle = HitboxSection:Toggle({
        Title = "Ativar Hitbox Expander",
        Desc = "Aumenta a área de acerto dos jogadores",
        Icon = "check",
        Type = "Checkbox",
        Callback = function(value)
            CombatModule.ActivateHitboxExpander(value)
        end
    })
    HitboxSection:Slider({
        Title = "Tamanho da Hitbox",
        Desc = "Tamanho da área expandida",
        Step = 1,
        Value = {
            Min = 2,
            Max = 30,
            Default = 10,
        },
        Callback = function(value)
            CombatModule.SetHitboxSize(value)
        end
    })
    HitboxSection:Slider({
        Title = "Transparência",
        Desc = "Visibilidade da hitbox (0 = invisível, 1 = visível)",
        Step = 0.1,
        Value = {
            Min = 0,
            Max = 1,
            Default = 0.5,
        },
        Callback = function(value)
            CombatModule.SetHitboxTransparency(value)
        end
    })
    local VehicleTab = Window:Tab({
        Title = "Veículos",
        Icon = "car-front",
        IconColor = Color3.fromRGB(138, 43, 226),
    })
    local VehicleSection = VehicleTab:Section({
        Title = "Configurações",
    })
    local VehicleColorsSection = VehicleTab:Section({
        Title = "Cores",
    })
    State.Features.AutoUnlock.toggle = VehicleSection:Toggle({
        Title = "Destrancar Todos (Auto)",
        Desc = "Destrava veículos A-Chassis automaticamente",
        Icon = "check",
        Type = "Checkbox",
        Callback = function(value)
            ExploitModule.ActivateAutoUnlock(value)
        end
    })
    VehicleSection:Button({
        Title = "Destrancar Todos Agora",
        Desc = "Destrava veículos A-Chassis no alcance",
        Callback = function()
            local count = VehicleModule.UnlockAllVehicles()
            WindUI:Notify({
                Title = "Veículos",
                Content = count .. " veículo(s) A-Chassis destravado(s)!",
                Icon = "unlock"
            })
        end
    })
    VehicleSection:Slider({
        Title = "Alcance",
        Desc = "Distância em studs",
        Step = 10,
        Value = {
            Min = 50,
            Max = 500,
            Default = Config.Defaults.VehicleRange,
        },
        Callback = function(value)
            VehicleModule.SetUnlockRange(value)
        end
    })
    State.Features.VehicleDelete.toggle = VehicleSection:Toggle({
        Title = "Deletar Veículo Próximo",
        Desc = "Clique no veículo para deletar (afundar)",
        Icon = "check",
        Type = "Checkbox",
        Callback = function(value)
            ExploitModule.ActivateVehicleDelete(value)
        end
    })
    VehicleSection:Button({
        Title = "Teleport Veículo Próximo",
        Desc = "Teleporta e entra no veículo mais próximo",
        Callback = function()
            ExploitModule.TeleportToNearestVehicle()
            WindUI:Notify({
                Title = "Teleport Veículo",
                Content = "Teleportado para veículo próximo",
                Icon = "car-front"
            })
        end
    })
    State.Features.VehicleFly.toggle = VehicleSection:Toggle({
        Title = "Voar com Carro",
        Desc = "Voar com veículo (W S A D Q E)",
        Icon = "check",
        Type = "Checkbox",
        Callback = function(value)
            ExploitModule.ActivateVehicleFly(value)
        end
    })
    State.Features.VehicleNoclip.toggle = VehicleSection:Toggle({
        Title = "Atravessar Paredes com Carro",
        Desc = "Noclip com veículo",
        Locked = true,
        Icon = "check",
        Type = "Checkbox",
        Callback = function(value)
            ExploitModule.ActivateVehicleNoclip(value)
        end
    })
    local PortaMalasSection = VehicleTab:Section({
        Title = "Sistema de Porta-Malas",
    })
    local vehicleDropdownsContainer = {}
    local function updatePortaMalas(vehicleData)
        for _, dropdown in pairs(vehicleDropdownsContainer) do
            if dropdown and dropdown.Destroy then
                pcall(function() dropdown:Destroy() end)
            end
        end
        vehicleDropdownsContainer = {}
        vehicleData = vehicleData or PortaMalasModule.GetVehicleData()
        if #vehicleData == 0 then
            if State.PortaMalas.statusLabel then
                pcall(function()
                    State.PortaMalas.statusLabel:Set({
                        Title = "Status: Nenhum veículo A-Chassis com porta-malas • " .. os.date("%H:%M:%S")
                    })
                end)
            end
            return
        end
        for _, data in ipairs(vehicleData) do
            if #data.items > 0 then
                local success, dropdown = pcall(function()
                    return PortaMalasSection:Dropdown({
                        Title = data.name,
                        Desc = data.itemCount .. " item(ns) no porta-malas",
                        Values = data.items,
                        Value = "",
                        Callback = function(value)
                            if value and value ~= "" then
                                local cloneSuccess, message = PortaMalasModule.CloneItem(value, data.name)
                                WindUI:Notify({
                                    Title = cloneSuccess and "Sucesso" or "Erro",
                                    Content = message,
                                    Icon = cloneSuccess and "check" or "x"
                                })
                            end
                        end
                    })
                end)
                if success and dropdown then
                    table.insert(vehicleDropdownsContainer, dropdown)
                end
            end
        end
        if State.PortaMalas.statusLabel then
            pcall(function()
                State.PortaMalas.statusLabel:Set({
                    Title = "Status: " .. #vehicleData .. " veículo(s) A-Chassis • " .. os.date("%H:%M:%S")
                })
            end)
        else
            local success, label = pcall(function()
                return PortaMalasSection:Section({
                    Title = "Status: " .. #vehicleData .. " veículo(s) A-Chassis • " .. os.date("%H:%M:%S"),
                })
            end)
            if success then
                State.PortaMalas.statusLabel = label
            end
        end
        State.PortaMalas.lastRefreshTime = tick()
        State.PortaMalas.isRefreshing = false
    end
    PortaMalasSection:Button({
        Title = "Iniciar Monitoramento",
        Desc = "Monitora mudanças nos porta-malas",
        Callback = function()
            PortaMalasModule.StartMonitoring(updatePortaMalas)
            WindUI:Notify({
                Title = "Monitoramento",
                Content = "Sistema ativado",
                Icon = "eye"
            })
        end
    })
    PortaMalasSection:Button({
        Title = "Parar Monitoramento",
        Desc = "Para o monitoramento",
        Callback = function()
            PortaMalasModule.StopMonitoring()
            WindUI:Notify({
                Title = "Monitoramento",
                Content = "Sistema desativado",
                Icon = "eye-off"
            })
        end
    })
    PortaMalasSection:Button({
        Title = "Atualizar Porta-Malas",
        Desc = "Recarrega a lista de veículos A-Chassis",
        Callback = function()
            if not State.PortaMalas.isRefreshing then
                State.PortaMalas.isRefreshing = true
                updatePortaMalas()
            end
        end
    })
    PortaMalasSection:Button({
        Title = "Limpar Clones",
        Desc = "Remove porta-malas clonados",
        Callback = function()
            local count = PortaMalasModule.ClearClonedTrunk()
            WindUI:Notify({
                Title = "Limpeza",
                Content = count > 0 and (count .. " item(ns) removido(s)") or "Nada para limpar",
                Icon = "trash-2"
            })
        end
    })
    task.wait(0.5)
    updatePortaMalas()
    local HubsTab = Window:Tab({
        Title = "Hubs",
        Icon = "squares-exclude",
        IconColor = Color3.fromRGB(138, 43, 226),
    })
    HubsTab:Button({
        Title = "IY Remodel",
        Desc = "Carrega Infinite Yield Remodel",
        Callback = function()
            if not loadstring then
                WindUI:Notify({
                    Title = "Erro",
                    Content = "loadstring não disponível",
                    Icon = "x"
                })
                return
            end
            Utils.SafeCall(function()
                loadstring(game:HttpGet(Config.externos.IYRemodel))()
            end)
        end
    })
    HubsTab:Button({
        Title = "Pedroxz Menu",
        Desc = "Carrega menu do Pedroxz",
        Callback = function()
            if not loadstring then
                WindUI:Notify({
                    Title = "Erro",
                    Content = "loadstring não disponível",
                    Icon = "x"
                })
                return
            end
            Utils.SafeCall(function()
                loadstring(game:HttpGet(Config.externos.PedroxzMenu))()
            end)
        end
    })
    Window:Divider()
    local SettingsTab = Window:Tab({
        Title = "Configurações",
        Icon = "settings",
        IconColor = Color3.fromRGB(138, 43, 226),
    })
    SettingsTab:Section({
        Title = "Controles do Menu",
        Icon = "keyboard",
    })
    SettingsTab:Section({
        Title = Utils.IsMobile() and "3 Dedos (2x) - Ocultar/Mostrar" or "Tecla F3 - Ocultar/Mostrar",
    })
    SettingsTab:Section({
        Title = "Informações",
        Icon = "info",
    })
    SettingsTab:Section({
        Title = "Versão: " .. Config.Version,
    })
    local DangerZoneSection = SettingsTab:Section({
        Title = "Área de Risco",
        Icon = "triangle-alert",
    })
    SettingsTab:Button({
        Title = "Bypass Telagem",
        Desc = "Desliga todos os exploits ativos",
        Callback = function()
            BypassTelagem(WindUI)
        end
    })
end
-- ==========================================
-- VERIFICAÇÃO DE USUÁRIO
-- ==========================================
local function IsUserAllowed()
    local success, response = pcall(function()
        return game:HttpGet(Config.AllowedUsersURL)
    end)
    if not success then
        return false
    end
    local allowed = {}
    for line in response:gmatch("[^\r\n]+") do
        local trimmed = line:match("^%s*(.-)%s*$")
        if trimmed ~= "" and not trimmed:match("^#") then
            allowed[trimmed] = true
        end
    end
    return allowed[LocalPlayer.Name] or false
end
-- ==========================================
-- INICIALIZAÇÃO DA UI
-- ==========================================
local function InitializeMainUI(WindUI)
    if not IsUserAllowed() then
        WindUI:Notify({
            Title = "Acesso Negado",
            Content = "Você não está autorizado a usar este menu. Contate o administrador.",
            Icon = "x",
            Duration = 10
        })
        return
    end

    WindUI:AddTheme({
        Name = "Purple Dark Glow",
        Accent = WindUI:Gradient({
            ["0"] = { Color = Color3.fromHex("#2e1065"), Transparency = 0 },
            ["100"] = { Color = Color3.fromHex("#1e1b4b"), Transparency = 0 },
        }, { Rotation = 90 }),
        Background = Color3.fromHex("#0f0f17"),
        BackgroundTransparency = 0,
        Outline = Color3.fromHex("#4c1d95"),
        Text = Color3.fromHex("#e4e4ff"),
        Placeholder = Color3.fromHex("#71717a"),
        Button = Color3.fromHex("#1e1b4b"),
        Icon = Color3.fromHex("#c4b5fd"),
        Hover = Color3.fromHex("#c4b5fd"),
        WindowBackground = Color3.fromHex("#0f0f17"),
        WindowShadow = Color3.fromHex("#000000"),
        DialogBackground = Color3.fromHex("#1e1b4b"),
        TabBackground = Color3.fromHex("#1e1b4b"),
        ElementBackground = Color3.fromHex("#1e1b4b"),
        PopupBackground = Color3.fromHex("#1e1b4b"),
        Toggle = Color3.fromHex("#1e1b4b"),
        ToggleBar = Color3.fromHex("#a78bfa"),
        Checkbox = Color3.fromHex("#1e1b4b"),
        CheckboxIcon = Color3.fromHex("#a78bfa"),
        Slider = Color3.fromHex("#1e1b4b"),
        SliderThumb = Color3.fromHex("#a78bfa"),
        Glow = true, -- Ativa o efeito de glow (se suportado pela WindUI)
    })

    WindUI:SetTheme("Purple Dark Glow")

    local Window = WindUI:CreateWindow({
        Title = Config.Title,
        Icon = "https://www.roblox.com/asset/?id=81127879201153",
        Author = Config.Author,
        Folder = "DNMenuConfig",
        Size = UDim2.fromOffset(580, 460),
        Transparent = true,
        Theme = "Purple Dark Glow",
        User = Config.User,
    })
    State.UI.window = Window
    task.spawn(function()
        for _, gui in ipairs(PlayerGui:GetChildren()) do
            if gui:IsA("ScreenGui") and gui:FindFirstChild("Holder") then
                State.UI.screenGui = gui
                break
            end
        end
    end)
    Window:EditOpenButton({
        Title = "DN Menu",
        Icon = "https://www.roblox.com/asset/?id=81127879201153",
        CornerRadius = UDim.new(0, 20),
        StrokeThickness = 2,
        Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, Color3.fromHex("#090909")),
            ColorSequenceKeypoint.new(1, Color3.fromHex("#181818"))
        }),
        OnlyMobile = false,
        Enabled = true,
        Draggable = true,
    })
    SetupToggleVisibility(Window)
    SetupAutoCleanup(Window)
    AuthModule.StartAuthVerification()
    task.spawn(function()
        task.wait(1.5)
        local success = pcall(function()
            if request then
                request({
                    Url = "http://localhost:6463/rpc?v=1",
                    Method = "POST",
                    Headers = {["Content-Type"] = "application/json"},
                    Body = Services.HttpService:JSONEncode({
                        cmd = "INVITE_BROWSER",
                        args = {code = "vBPFAg8kHW"},
                        nonce = tostring(math.random(100000, 999999))
                    })
                })
            end
        end)
        if not success then
            setclipboard(Config.DiscordInvite)
        end
    end)
    AddMenuElements(Window, WindUI)
end
local function Main()
    if not LocalPlayer.Character then
        LocalPlayer.CharacterAdded:Wait()
    end
    local success, result = pcall(function()
        return loadstring(game:HttpGet("https://raw.githubusercontent.com/Footagesus/WindUI/main/dist/main.lua"))()
    end)
    if not success then
        warn("[DN Menu] Erro ao carregar WindUI:", result)
        return
    end
    local WindUI = result
    if not WindUI then
        warn("[DN Menu] WindUI retornou nil")
        return
    end
    InitializeMainUI(WindUI)
end
Main()
